{"meta":{"title":"JUST DO IT","subtitle":"52it.party","description":"一个爱好it的开源站点","author":"Jerry Wang","url":"https://52it.party"},"pages":[{"title":"","date":"2018-07-10T02:01:39.774Z","updated":"2018-07-10T02:01:39.774Z","comments":false,"path":"categories/index.html","permalink":"https://52it.party/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-07-10T02:01:05.148Z","updated":"2018-07-10T02:01:05.148Z","comments":false,"path":"tags/index.html","permalink":"https://52it.party/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Bip44确定性算法的android实现","slug":"Bip44确定性算法的android实现","date":"2018-12-06T03:24:17.000Z","updated":"2018-12-06T03:53:22.482Z","comments":true,"path":"2018/12/06/Bip44确定性算法的android实现/","link":"","permalink":"https://52it.party/2018/12/06/Bip44确定性算法的android实现/","excerpt":"","text":"简介这是一个Bip44确定性算法的Android实现库，可以生成12个助记词，seed种子和根据path路径生成路径的私钥. 对Bip44确定算法不了解的可以看我之前的一篇文章：https://52it.party/2018/07/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91%E4%B9%8B%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%AE%97%E6%B3%95bip32%EF%BC%8Cbip39%EF%BC%8Cbip44/ 项目地址：https://github.com/wypeng2012/Bip44ForAndroid 欢迎star suppor Android sdk &gt;= 14 - 如何使用 代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445 //get 12 words List&lt;String&gt; words = Bip44Utils.generateMnemonicWords(MainActivity.this); Log.e(\"TAG\", \"words: \" + words.toString()); // get bip39 seed byte[] seed = Bip44Utils.getSeed(words); Log.e(\"TAG\", \"seed: \" + new BigInteger(1,seed).toString(16)); //get PrivateKey by path BigInteger pri1 = Bip44Utils.getPathPrivateKey(words,\"m/44'/194'/0'/0/0\"); Log.e(\"TAG\", \"pri1: \" + pri1.toString(16)); BigInteger pri2 = Bip44Utils.getPathPrivateKey(words,seed,\"m/44'/194'/0'/0/0\"); Log.e(\"TAG\", \"pri2: \" + pri2.toString(16)); byte[] pri3 = Bip44Utils.getPathPrivateKeyBytes(words, \"m/44'/194'/0'/0/0\"); Log.e(\"TAG\", \"pri3: \" + new BigInteger(1,pri3).toString(16)); byte[] pri4 = Bip44Utils.getPathPrivateKeyBytes(words, seed,\"m/44'/194'/0'/0/0\"); Log.e(\"TAG\", \"pri4: \" + new BigInteger(1,pri4).toString(16)); byte[] pri5 = Bip44Utils.getDefaultPathPrivateKeyBytes(words, 194); Log.e(\"TAG\", \"pri5: \" + new BigInteger(1,pri5).toString(16)); //if you use bitcoinj library,you can generate bitcoin privatekey and public key and address like this: BigInteger pribtc = Bip44Utils.getPathPrivateKey(words,\"m/44'/0'/0'/0/0\"); ECKey ecKey = ECKey.fromPrivate(pribtc); String publicKey = ecKey.getPublicKeyAsHex(); String privateKey = ecKey.getPrivateKeyEncoded(networkParameters).toString(); String address = ecKey.toAddress(networkParameters).toString(); //if you use web3j library,you can generate bitcoin privatekey and public key and address like this:BigInteger prieth = Bip44Utils.getPathPrivateKey(words,\"m/44'/60'/0'/0/0\"); ECKeyPair ecKeyPair = ECKeyPair.create(prieth); String publicKey = Numeric.toHexStringWithPrefix(ecKeyPair.getPublicKey()); String privateKey = Numeric.toHexStringWithPrefix(ecKeyPair.getPrivateKey()); String address = \"0x\" + Keys.getAddress(ecKeyPair); 打印结果:1234567891011121314words: [course, question, calm, west, basket, kitten, salmon, absorb, tool, ankle, mixed, endorse]seed: c03f5488370482658066b96a803fcceac46b68181024a545d814344cbf7d9da9b478a20d0b95ebef268b7c24afd4540c59a4567146d45d2db891ca2576d409c7pri1: 6ef7a396546d4fcf26865e54033ad48db858d19b5a08782014a652f4b5469037pri2: 6ef7a396546d4fcf26865e54033ad48db858d19b5a08782014a652f4b5469037pri3: 6ef7a396546d4fcf26865e54033ad48db858d19b5a08782014a652f4b5469037pri4: 6ef7a396546d4fcf26865e54033ad48db858d19b5a08782014a652f4b5469037pri5: 6ef7a396546d4fcf26865e54033ad48db858d19b5a08782014a652f4b5469037 - 如何远程依赖 Maven 123456&lt;dependency&gt; &lt;groupId&gt;party.loveit&lt;/groupId&gt; &lt;artifactId&gt;bip44forandroidlibrary&lt;/artifactId&gt; &lt;version&gt;1.0.7&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; Gradle 12345compile &apos;party.loveit:bip44forandroidlibrary:1.0.7&apos;orimplementation &apos;party.loveit:bip44forandroidlibrary:1.0.7&apos; Ivy 123&lt;dependency org=&apos;party.loveit&apos; name=&apos;bip44forandroidlibrary&apos; rev=&apos;1.0.7&apos;&gt; &lt;artifact name=&apos;bip44forandroidlibrary&apos; ext=&apos;pom&apos; &gt;&lt;/artifact&gt;&lt;/dependency&gt;","categories":[{"name":"Android开源库","slug":"Android开源库","permalink":"https://52it.party/categories/Android开源库/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://52it.party/tags/Android开发/"},{"name":"Android开源库","slug":"Android开源库","permalink":"https://52it.party/tags/Android开源库/"}]},{"title":"Android开发之限制EditText的长度（中英文或者其他国家文字混编）","slug":"Android开发之限制EditText的长度（中英文或者其他国家文字混编）","date":"2018-08-07T08:59:25.000Z","updated":"2018-08-07T09:07:03.690Z","comments":true,"path":"2018/08/07/Android开发之限制EditText的长度（中英文或者其他国家文字混编）/","link":"","permalink":"https://52it.party/2018/08/07/Android开发之限制EditText的长度（中英文或者其他国家文字混编）/","excerpt":"","text":"引言在开发中难免会碰到限制EditText长的的需求，最简单的做法就是设置maxLength属性，但是这个是不准确的，他的计算方式是按照字符数，算的，但是现实使用中，同样字符长度的汉字是比英文或者字符要长的，所以要按照是否中文和英文或者混排，来限制长度，一般汉字按照两个来计算的。Android里边使用自定义InputFilter来实现，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class CustomCoinNameFilter implements InputFilter &#123; private int maxLength;//最大长度，ASCII码算一个，其它算两个 public CustomCoinNameFilter(int maxLength) &#123; this.maxLength = maxLength; &#125; @Override public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) &#123; if (TextUtils.isEmpty(source)) &#123; return null; &#125; LogUtils.e(\"source:\" + source); LogUtils.e(\"dest:\" + dest); int inputCount = 0; int destCount = 0; inputCount = getCurLength(source); LogUtils.e(\"inputCount:\" + inputCount); if (dest.length() != 0) destCount = getCurLength(dest); LogUtils.e(\"destCount:\" + destCount); if (destCount &gt;= maxLength) return \"\"; else &#123; int count = inputCount + destCount; if (dest.length() == 0) &#123; if (count &lt;= maxLength) return null; else return sub(source, maxLength); &#125; LogUtils.e(\"count:\" + count); if (count &gt; maxLength) &#123; //int min = count - maxLength; int maxSubLength = maxLength - destCount; return sub(source, maxSubLength); &#125; &#125; return null; &#125; private CharSequence sub(CharSequence sq, int subLength) &#123; int needLength = 0; int length = 0; for (int i = 0; i &lt; sq.length(); i++) &#123; if (sq.charAt(i) &lt; 128) length += 1; else length += 2; ++needLength; if (subLength &lt;= length) &#123; return sq.subSequence(0, needLength); &#125; &#125; return sq; &#125; private int getCurLength(CharSequence s) &#123; int length = 0; if (s == null) return length; else &#123; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) &lt; 128) length += 1; else length += 2; &#125; &#125; return length; &#125;&#125; 使用1mSetWalletName.setFilters(new InputFilter[]&#123;new CustomCoinNameFilter(20)&#125;);","categories":[{"name":"Android问题解决","slug":"Android问题解决","permalink":"https://52it.party/categories/Android问题解决/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://52it.party/tags/Android开发/"},{"name":"Android问题解决","slug":"Android问题解决","permalink":"https://52it.party/tags/Android问题解决/"}]},{"title":"区块链开发之BTC消息签名和消息验证","slug":"区块链开发之BTC消息签名和消息验证","date":"2018-08-03T05:34:45.000Z","updated":"2018-08-03T05:40:11.376Z","comments":true,"path":"2018/08/03/区块链开发之BTC消息签名和消息验证/","link":"","permalink":"https://52it.party/2018/08/03/区块链开发之BTC消息签名和消息验证/","excerpt":"","text":"BTC的消息签名机制，是使用私钥对一段信息签名，然后使用公钥对此签名做校验，次机制可以作为验证消息真伪的手段，这里使用bitcoinj库实现的 implementation ‘org.bitcoinj:bitcoinj-core:0.14.7’ 对消息进行签名123456789101112131415/** * @param msg 要签名的信息 * @param privateKey 私钥 * @return */ public static String signMsg(@NonNull String msg, @NonNull String privateKey) &#123; NetworkParameters networkParameters = null; if (!BTC_TEST_NET) networkParameters = MainNetParams.get(); else networkParameters = TestNet3Params.get(); DumpedPrivateKey priKey = DumpedPrivateKey.fromBase58(networkParameters, privateKey); ECKey ecKey = priKey.getKey(); return ecKey.signMessage(msg); &#125; 验证签名消息1234567891011121314151617181920/** * @param msg 明文 * @param signatureMsg 签名好的信息 * @param pubkey 公钥 * @return */ public static boolean verifyMessage(@NonNull String msg, @NonNull String signatureMsg, @NonNull String pubkey) &#123; boolean result = false; ECKey ecKey = ECKey.fromPublicOnly(Utils.HEX.decode(pubkey)); try &#123; ecKey.verifyMessage(msg, signatureMsg); result = true; &#125; catch (SignatureException e) &#123; result = false; e.printStackTrace(); &#125; finally &#123; return result; &#125; &#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"BTC","slug":"BTC","permalink":"https://52it.party/tags/BTC/"},{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"}]},{"title":"获取ETH指定代币的余额","slug":"获取ETH指定代币的余额","date":"2018-08-02T07:10:06.000Z","updated":"2018-08-02T08:20:54.080Z","comments":true,"path":"2018/08/02/获取ETH指定代币的余额/","link":"","permalink":"https://52it.party/2018/08/02/获取ETH指定代币的余额/","excerpt":"","text":"引言之前的文章介绍了获取eth余额的方法和离线签名的方法（指定代币的离线签名），今天就来介绍一下如何获取满足ERC20协议的代币余额的。 要想获取代币的余额，要通过rpc接口得到接口为：eth_call 参数 1.object字段： from: 钱包地址 to: 代币地址（智能合约地址） data：0x70a08231000000000000000000000000b60e8dd61c5d32be8058bb8eb970870f07233155 data数据格式：最前边的“0x70a08231000000000000000000000000”是固定的，后边的是钱包地址（不带“0x”前缀） 2.QUANTITY|TAG，”latest”, “earliest” or “pending” 参数示例12345params: [&#123; &quot;from&quot;: &quot;0xb60e8dd61c5d32be8058bb8eb970870f07233155&quot;, &quot;to&quot;: &quot;0xd46e8dd67c5d32be8058bb8eb970870f07244567&quot;, &quot;data&quot;: &quot;0x70a08231000000000000000000000000b60e8dd61c5d32be8058bb8eb970870f072331555675&quot;&#125;,&quot;latest&quot;] 请求示例123456789// Requestcurl -X POST --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_call&quot;,&quot;params&quot;:[&#123;see above&#125;],&quot;id&quot;:1&#125;&apos;// Result&#123; &quot;id&quot;:1, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: &quot;0x&quot;&#125; 注：result字段的值，就是余额","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"ETH","slug":"ETH","permalink":"https://52it.party/tags/ETH/"},{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"}]},{"title":"区块链开发之计算BTC的fee小费","slug":"区块链开发之计算BTC的fee小费","date":"2018-08-02T05:43:51.000Z","updated":"2018-08-02T05:56:48.103Z","comments":true,"path":"2018/08/02/区块链开发之计算BTC的fee小费/","link":"","permalink":"https://52it.party/2018/08/02/区块链开发之计算BTC的fee小费/","excerpt":"","text":"引言btc的fee也是要经过计算得出的，而不是随便给的，它的计价方式是按照每笔交易的字节数收的，所以要先计算出你这比交易的fee，必须先计算出这笔交易可能的字节数，计算公式如下： 148 x inputNum + 34 x outputNum + 10 算出字节数后，再乘以rate（Satoshi/byte）,rate可以网上找接口获取 提示：所以为了转账少花手续费，最好把utxo列表根据余额从大到小做个排序 代码实现：123456789101112131415161718192021222324252627/*** * * @param unSpentBTCList * @param value * @param rate sta/byte * @return -1发送的value超出了你的余额 */public static long getFee(@NonNull List&lt;UnSpentBTC&gt; unSpentBTCList, long value, int rate) &#123; long fee = 0L; int inputNum = 0; long totalMoney = 0; for (UnSpentBTC us : unSpentBTCList) &#123; inputNum++; totalMoney += us.getSatoshis(); if (totalMoney &gt; value) &#123; fee = (148 * inputNum + 34 * 1 + 10) * rate; if (totalMoney == (value + fee)) return fee; else if (totalMoney &gt; (value + fee)) &#123; fee = (148 * inputNum + 34 * 2 + 10) * rate; if (totalMoney &gt;= (value + fee)) return fee; &#125; &#125; &#125; return -1;&#125; 有的朋友可能还会需要算出，最大能够发送的钱数，我这里也给一下代码，仅做参考： 123456789101112131415161718192021/** * @param unSpentBTCList * @param totalMoney * @return */public static long getMaxSendValue(List&lt;UnSpentBTC&gt; unSpentBTCList, long totalMoney, int rate) &#123; while (true) &#123; long fee = getFee(unSpentBTCList, totalMoney, rate); if (fee == -1) totalMoney -= 100; else break; &#125; /* long fee = getFee(unSpentBTCList, totalMoney, rate); if (fee == -1) &#123; totalMoney -= 100; getMaxSendValue(unSpentBTCList, totalMoney, rate); &#125;*/ return totalMoney;&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"BTC","slug":"BTC","permalink":"https://52it.party/tags/BTC/"},{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"}]},{"title":"区块链开发之ETH离线签名和其代币离线签名","slug":"区块链开发之ETH离线签名和其代币离线签名","date":"2018-08-02T05:35:02.000Z","updated":"2018-08-02T05:38:22.921Z","comments":true,"path":"2018/08/02/区块链开发之ETH离线签名和其代币离线签名/","link":"","permalink":"https://52it.party/2018/08/02/区块链开发之ETH离线签名和其代币离线签名/","excerpt":"","text":"引言eth的离线签名没有btc那么繁琐，只需要设置好nonce，gasprice和gaslimit即可 eth离线签名12345678910111213141516171819202122232425/** * 离线签名eth * * @param to//转账的钱包地址 * @param nonce//获取到的交易次数 * @param gasPrice * @param gasLimit * @param value //转账的值 * @return */ public static String signedEthTransactionData(String privateKey, String to, BigInteger nonce, BigInteger gasPrice, BigInteger gasLimit, String value) throws Exception &#123; if (words == null || words.size() != 12) &#123; throw new RuntimeException(\"please generateMnemonic first\"); &#125; //把十进制的转换成ETH的Wei, 1ETH = 10^18 Wei BigDecimal realValue = Convert.toWei(value, Convert.Unit.ETHER); RawTransaction rawTransaction = RawTransaction.createEtherTransaction(nonce, gasPrice, gasLimit, to, realValue.toBigIntegerExact()); //手续费= (gasPrice * gasLimit ) / 10^18 ether Credentials credentials = Credentials.create(privateKey); //使用TransactionEncoder对RawTransaction进行签名操作 byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials); // //转换成0x开头的字符串 return Numeric.toHexString(signedMessage); &#125; 代币转账代码：1234567891011121314151617181920212223242526272829/** * 离线签名eth * * @param contractAddress//合约地址 * @param to//转账的钱包地址 * @param nonce//获取到的交易次数 * @param gasPrice * @param gasLimit * @param value //转账的值 * @return */public static String signedEthContractTransactionData(String privateKey, String contractAddress, String to, BigInteger nonce, BigInteger gasPrice, BigInteger gasLimit, Double value, Double decimal) throws Exception &#123; if (words == null || words.size() != 12) &#123; throw new RuntimeException(\"please generateMnemonic first\"); &#125; //因为每个代币可以规定自己的小数位, 所以实际的转账值=数值 * 10^小数位 BigDecimal realValue = BigDecimal.valueOf(value * Math.pow(10.0, decimal)); //0xa9059cbb代表某个代币的转账方法hex(transfer) + 对方的转账地址hex + 转账的值的hex String data = \"0xa9059cbb\" + Numeric.toHexStringNoPrefixZeroPadded(Numeric.toBigInt(to), 64) + Numeric.toHexStringNoPrefixZeroPadded(realValue.toBigInteger(), 64); RawTransaction rawTransaction = RawTransaction.createTransaction(nonce, gasPrice, gasLimit, contractAddress, data); //手续费= (gasPrice * gasLimit ) / 10^18 ether Credentials credentials = Credentials.create(privateKey); //使用TransactionEncoder对RawTransaction进行签名操作 byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials); //转换成0x开头的字符串 return Numeric.toHexString(signedMessage);&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"BTC","slug":"BTC","permalink":"https://52it.party/tags/BTC/"},{"name":"ETH","slug":"ETH","permalink":"https://52it.party/tags/ETH/"},{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"}]},{"title":"区块链开发之BTC离线签名","slug":"区块链开发之BTC离线签名","date":"2018-08-02T03:27:19.000Z","updated":"2018-08-02T03:38:42.330Z","comments":true,"path":"2018/08/02/区块链开发之BTC离线签名/","link":"","permalink":"https://52it.party/2018/08/02/区块链开发之BTC离线签名/","excerpt":"","text":"引言btc的账户系统是基于utxo模式的（utxo具体解释，大家可以自行搜索），如何获取utxo列表，可以看我前篇文章：区块链开发之获取BTC，ETH的余额，BTC的UTXO列表，ETH的nonce 获取到的数据格式大致如下12345678910111213141516171819202122[ &#123; \"address\":\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\", \"txid\":\"d5f8a96faccf79d4c087fa217627bb1120e83f8ea1a7d84b1de4277ead9bbac1\", \"vout\":0, \"scriptPubKey\":\"76a91453c0307d6851aa0ce7825ba883c6bd9ad242b48688ac\", \"amount\":0.000006, \"satoshis\":600, \"confirmations\":0, \"ts\":1461349425 &#125;, &#123; \"address\": \"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\", \"txid\": \"bc9df3b92120feaee4edc80963d8ed59d6a78ea0defef3ec3cb374f2015bfc6e\", \"vout\": 1, \"scriptPubKey\": \"76a91453c0307d6851aa0ce7825ba883c6bd9ad242b48688ac\", \"amount\": 0.12345678, \"satoshis: 12345678, \"confirmations\": 1, \"height\": 300001 &#125;] 具体代码如下1234567891011121314151617181920212223242526272829303132333435363738394041public static String signBTCTransactionData(@NonNull List&lt;UnSpentBTC&gt; unSpentBTCList, @NonNull String from, @NonNull String to, @NonNull String privateKey, long value, long fee) throws Exception &#123; NetworkParameters networkParameters = null; if (!BTC_TEST_NET) networkParameters = MainNetParams.get(); else networkParameters = TestNet3Params.get(); Transaction transaction = new Transaction(networkParameters); DumpedPrivateKey dumpedPrivateKey = DumpedPrivateKey.fromBase58(networkParameters, privateKey); ECKey ecKey = dumpedPrivateKey.getKey(); long totalMoney = 0; List&lt;UTXO&gt; utxos = new ArrayList&lt;&gt;(); //遍历未花费列表，组装合适的item for (UnSpentBTC us : unSpentBTCList) &#123; if (totalMoney &gt;= (value + fee)) break; UTXO utxo = new UTXO(Sha256Hash.wrap(us.getTxid()), us.getVout(), Coin.valueOf(us.getSatoshis()), us.getHeight(), false, new Script(Hex.decode(us.getScriptPubKey()))); utxos.add(utxo); totalMoney += us.getSatoshis(); &#125; transaction.addOutput(Coin.valueOf(value), Address.fromBase58(networkParameters, to)); // transaction. //消费列表总金额 - 已经转账的金额 - 手续费 就等于需要返回给自己的金额了 long balance = totalMoney - value - fee; //输出-转给自己 if (balance &gt; 0) &#123; transaction.addOutput(Coin.valueOf(balance), Address.fromBase58(networkParameters, from)); &#125; //输入未消费列表项 for (UTXO utxo : utxos) &#123; TransactionOutPoint outPoint = new TransactionOutPoint(networkParameters, utxo.getIndex(), utxo.getHash()); transaction.addSignedInput(outPoint, utxo.getScript(), ecKey, Transaction.SigHash.ALL, true); &#125; return Hex.toHexString(transaction.bitcoinSerialize()); &#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"BTC","slug":"BTC","permalink":"https://52it.party/tags/BTC/"},{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"}]},{"title":"区块链开发之获取BTC，ETH的余额，BTC的UTXO列表，ETH的nonce","slug":"区块链开发之获取BTC，ETH的余额，BTC的UTXO列表，ETH的nonce","date":"2018-08-02T02:55:55.000Z","updated":"2018-08-02T03:21:58.297Z","comments":true,"path":"2018/08/02/区块链开发之获取BTC，ETH的余额，BTC的UTXO列表，ETH的nonce/","link":"","permalink":"https://52it.party/2018/08/02/区块链开发之获取BTC，ETH的余额，BTC的UTXO列表，ETH的nonce/","excerpt":"","text":"获取eth的余额先来说说eth的余额获取，这个是很简单的，直接通过节点的rpc接口，就可以获取到，具体使用到的RPC接口为：eth_getBalance 参数：1.要查询钱包地址2.查询不同状态的余额”latest”（已经确认了的）, “earliest”（创世区块的） ， “pending”（包含未确认的交易的余额） 1234params: [ '0xc94770007dda54cF92009BFF0dE90c06F603a09f', 'latest'] 示例：123456789// Requestcurl -X POST --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_getBalance&quot;,&quot;params&quot;:[&quot;0xc94770007dda54cF92009BFF0dE90c06F603a09f&quot;, &quot;latest&quot;],&quot;id&quot;:1&#125;&apos;// Result&#123; &quot;id&quot;:1, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: &quot;0x0234c8a3397aab58&quot; // 158972490234375000&#125; 获取BTC的余额 和 UTXO列表直接使用btc节点的rpc服务是很难查出某个地址的余额的，因为btc的utxo机制，想通过rpc服务查余额，就只能先把地址导入节点，节点扫描整个区块，维护本地utxo列表，然后才能查询余额，这需要耗费一定的时间（20分钟以上），所以这个方式根本不适合查询余额。最终只能自己搭建一个btc的区块链浏览器，来解决这个问题（同时也解决了获取utxo列表和查询历史记录的问题）。使用的比较广的btc浏览器应该是insight-api，它的代码是开源的，并且提供接口，github地址：https://github.com/bitpay/insight-api 他提供的接口，足以满足你的需求 获取eth的nonce估计有些人会有疑问，nonce是用来干啥的呢？其实他是eth用来防止双花的机制： 为了防止交易的重播攻击，每笔交易必须有一个nonce随机数，针对每一个账户nonce都是从0开始，当nonce为0的交易处理完之后，才会处理nonce为1的交易，并依次加1的交易才会被处理。以下是nonce使用的几条规则： 当nonce太小，交易会被直接拒绝。 当nonce太大，交易会一直处于队列之中； 当发送一个比较大的nonce值，然后补齐开始nonce到那个值之间的nonce，那么交易依旧可以被执行。 那如何获取这个nonce和防止交易失败呢，那就应该使用rpc接口获取，并且获取pending状态的值，具体rpc接口为：eth_getTransactionCount 参数：1.要查询钱包地址2.查询不同状态的余额”latest”（已经确认了的）, “earliest”（创世区块的） ， “pending”（包含未确认的交易的次数，推荐使用这个） 1234params: [ '0xc94770007dda54cF92009BFF0dE90c06F603a09f', 'latest'] 示例：123456789// Requestcurl -X POST --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_getTransactionCount&quot;,&quot;params&quot;:[&quot;0xc94770007dda54cF92009BFF0dE90c06F603a09f&quot;,&quot;latest&quot;],&quot;id&quot;:1&#125;&apos;// Result&#123; &quot;id&quot;:1, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: &quot;0x1&quot; // 1&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"BTC","slug":"BTC","permalink":"https://52it.party/tags/BTC/"},{"name":"ETH","slug":"ETH","permalink":"https://52it.party/tags/ETH/"},{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"}]},{"title":"区块链开发之验证ETH地址的有效性","slug":"区块链开发之验证ETH地址的有效性","date":"2018-08-01T01:57:40.000Z","updated":"2018-08-01T02:14:20.116Z","comments":true,"path":"2018/08/01/区块链开发之验证ETH地址的有效性/","link":"","permalink":"https://52it.party/2018/08/01/区块链开发之验证ETH地址的有效性/","excerpt":"","text":"引言之前介绍了eth私钥公钥地址的生成，接下来介绍一下eth地址有效性的校验，要做地址有效性的校验，首先要知道他的地址规则： eth的地址，就是把公钥用sha256hash之后，取其后160位生成的16进制字符串（40个字符）再加上前缀“0x”（总共42位） 校验流程第一步,先判断地址非空和是否0x开头 第二步，把16进制字符串转成10进制数，看是否能否转换成功 第三部，判断是否长度是40位（去掉0x） 代码实现12345public static boolean isETHValidAddress(String input) &#123; if (StringUtils.isNull(input) || !input.startsWith(\"0x\")) return false; return WalletUtils.isValidAddress(input); &#125; isValidAddress方法 1234567891011public static boolean isValidAddress(String input) &#123; String cleanInput = Numeric.cleanHexPrefix(input); try &#123; Numeric.toBigIntNoPrefix(cleanInput); &#125; catch (NumberFormatException e) &#123; return false; &#125; return cleanInput.length() == ADDRESS_LENGTH_IN_HEX;&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"}]},{"title":"区块链开发之验证BTC地址的有效性","slug":"区块链开发之验证BTC地址的有效性","date":"2018-08-01T01:38:35.000Z","updated":"2018-08-01T01:57:09.927Z","comments":true,"path":"2018/08/01/区块链开发之验证BTC地址的有效性/","link":"","permalink":"https://52it.party/2018/08/01/区块链开发之验证BTC地址的有效性/","excerpt":"","text":"引言之前介绍了btc私钥公钥地址的生成，接下来介绍一下btc地址有效性的校验，要做地址有效性的校验，首先要知道他的地址生成规则： 第一步，随机选取一个32字节的数、大小介于1 ~ 0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4141之间，作为私钥。18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725 第二步，使用椭圆曲线加密算法（ECDSA-secp256k1）计算私钥所对应的非压缩公钥。 (共65字节， 1字节 0x04, 32字节为x坐标，32字节为y坐标）关于公钥压缩、非压缩的问题另文说明。 0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6 第三步，计算公钥的 SHA-256 哈希值600FFE422B4E00731A59557A5CCA46CC183944191006324A447BDB2D98D4B408 第四步，取上一步结果，计算 RIPEMD-160 哈希值010966776006953D5567439E5E39F86A0D273BEE 第五步，取上一步结果，前面加入地址版本号（比特币主网版本号“0x00”）00010966776006953D5567439E5E39F86A0D273BEE 第六步，取上一步结果，计算 SHA-256 哈希值445C7A8007A93D8733188288BB320A8FE2DEBD2AE1B47F0F50BC10BAE845C094 第七步，取上一步结果，再计算一下 SHA-256 哈希值（哈哈）D61967F63C7DD183914A4AE452C9F6AD5D462CE3D277798075B107615C1A8A30 第八步，取上一步结果的前4个字节（8位十六进制）D61967F6 第九步，把这4个字节加在第五步的结果后面，作为校验（这就是比特币地址的16进制形态）。00010966776006953D5567439E5E39F86A0D273BEED61967F6 第十步，用base58表示法变换一下地址（这就是最常见的比特币地址形态）。16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM 校验流程知道了生成流程，就好实现校验方法了。 第一步，先把地址base58解码成字节数组，然后把数组分成两个字节数组，一个是后4字节数组（字节数组1），一个是减去后4字节的数组（字节数组2），然后把字节数组2两次Sha256Hash，然后取其前4位，跟字节数组1比较，是相同的，就校验通过。 第二步，把第一步校验通过的解码字节数组取第一个字节&amp;0xff，得到版本号，然后检验版本号的合法性（这个是根据主网参数校验的） 代码实现这些代码bitcoinj里面已经有对应方法了，我们只需要封装一下就可以了，代码如下：12345678910111213141516public static boolean isBTCValidAddress(String input) &#123; try &#123; NetworkParameters networkParameters = null; if (!BTC_TEST_NET) networkParameters = MainNetParams.get(); else networkParameters = TestNet3Params.get(); Address address = Address.fromBase58(networkParameters, input); if (address != null) return true; else return false; &#125; catch (Exception e) &#123; return false; &#125;&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"}]},{"title":"区块链开发之确定性算法生成BTC，ETH的私钥，公钥和地址","slug":"区块链开发之确定性算法生成BTC，ETH的私钥，公钥和地址","date":"2018-07-30T11:21:08.000Z","updated":"2018-07-30T11:37:27.843Z","comments":true,"path":"2018/07/30/区块链开发之确定性算法生成BTC，ETH的私钥，公钥和地址/","link":"","permalink":"https://52it.party/2018/07/30/区块链开发之确定性算法生成BTC，ETH的私钥，公钥和地址/","excerpt":"","text":"引言首先要生成12个助记词，请看我上篇文章：区块链开发之生成12个助记词 使用的库 implementation ‘org.bitcoinj:bitcoinj-core:0.14.7’ implementation ‘org.web3j:core:3.3.1-android’ 具体代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static ShellWallet generateWallet(int coinType, int index, String name) throws Exception &#123; ShellWallet wallet = null; if (words == null || words.size() != 12) &#123; throw new RuntimeException(\"please generateMnemonic first\"); &#125; else &#123; DeterministicSeed deterministicSeed = new DeterministicSeed(words, null, \"\", 0); DeterministicKeyChain deterministicKeyChain = DeterministicKeyChain.builder().seed(deterministicSeed).build(); //拼接路径 path = \"m/44'/60'/0'/0/0\" String path = null; if (coinType == BTC_COIN) &#123; path = \"m/44'/0'/0'/0/\" + index; NetworkParameters networkParameters = null; if (!BTC_TEST_NET) &#123; networkParameters = MainNetParams.get(); &#125; else &#123; networkParameters = TestNet3Params.get(); path = \"m/44'/1'/0'/0/\" + index; &#125; BigInteger privkeybtc = deterministicKeyChain.getKeyByPath(parsePath(path), true).getPrivKey(); ECKey ecKey = ECKey.fromPrivate(privkeybtc); //String publicKey = Numeric.toHexStringNoPrefixZeroPadded(new BigInteger(ecKey.getPubKey()), 66); //LogUtils.d(\"pub1:\" + publicKey ); String publicKey = ecKey.getPublicKeyAsHex(); LogUtils.d(\"pub2:\" + publicKey); String privateKey = ecKey.getPrivateKeyEncoded(networkParameters).toString(); String address = ecKey.toAddress(networkParameters).toString(); wallet = new ShellWallet(index, coinType, privateKey, publicKey, address, name); LogUtils.d(wallet.toString()); &#125; else if (coinType == ETH_COIN) &#123; path = \"m/44'/60'/0'/0/\" + index; BigInteger privkeyeth = deterministicKeyChain.getKeyByPath(parsePath(path), true).getPrivKey(); ECKeyPair ecKeyPair = ECKeyPair.create(privkeyeth); String publicKey = Numeric.toHexStringWithPrefix(ecKeyPair.getPublicKey()); String privateKey = Numeric.toHexStringWithPrefix(ecKeyPair.getPrivateKey()); String address = \"0x\" + Keys.getAddress(ecKeyPair); wallet = new ShellWallet(index, coinType, privateKey, publicKey, address, name); LogUtils.d(wallet.toString()); &#125; &#125; return wallet; &#125; 12345678910111213141516171819202122/** * The path is a human-friendly representation of the deterministic path. For example: * &lt;p&gt; * \"m/44'/0'/0'/0/0\" * &lt;p&gt; * Where a letter \"'\" means hardened key. Spaces are ignored. */ public static List&lt;ChildNumber&gt; parsePath(@Nonnull String path) &#123; String[] parsedNodes = path.replace(\"m\", \"\").split(\"/\"); List&lt;ChildNumber&gt; nodes = new ArrayList&lt;&gt;(); for (String n : parsedNodes) &#123; n = n.replaceAll(\" \", \"\"); if (n.length() == 0) continue; boolean isHard = n.endsWith(\"'\"); if (isHard) n = n.substring(0, n.length() - 1); int nodeNumber = Integer.parseInt(n); nodes.add(new ChildNumber(nodeNumber, isHard)); &#125; return nodes; &#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"}]},{"title":"区块链开发之生成12个助记词","slug":"区块链开发之生成12个助记词","date":"2018-07-30T11:01:11.000Z","updated":"2018-07-30T11:13:00.190Z","comments":true,"path":"2018/07/30/区块链开发之生成12个助记词/","link":"","permalink":"https://52it.party/2018/07/30/区块链开发之生成12个助记词/","excerpt":"","text":"这里使用bitcoinj库，来实现生成bip39的12个助记词，引用库 implementation ‘org.bitcoinj:bitcoinj-core:0.14.7’ 填坑1如果你直接引用库之后，直接安装运行apk，会造成app崩溃，这是因为这个库里面有一个libscrypt.dylib，这个库是针对x86_64平台的，并且没有其他平台的这个库，所以在arm cpu平台的手机app会崩溃，解决方案就是在gradle的android节点下，加上以下配置1234567packagingOptions &#123; exclude 'lib/x86_64/darwin/libscrypt.dylib' exclude 'com/google/thirdparty/publicsuffix/PublicSuffixPatterns.gwt.xml' exclude 'com/google/thirdparty/publicsuffix/PublicSuffixType.gwt.xml' exclude 'org/bitcoinj/crypto/mnemonic/wordlist/english.txt' exclude 'org/bitcoinj/crypto/cacerts' &#125; 填坑2我们要得到12个随机的单词，就要用到里面的MnemonicCode类，但是这个类，默认会new一个实例出来，并且默认加载的单词库路径方式是不支持android的，官方代码如下1234567891011static &#123; try &#123; INSTANCE = new MnemonicCode(); &#125; catch (FileNotFoundException e) &#123; // We expect failure on Android. The developer has to set INSTANCE themselves. if (!Utils.isAndroidRuntime()) log.error(\"Could not find word list\", e); &#125; catch (IOException e) &#123; log.error(\"Failed to load word list\", e); &#125; &#125; 1234567891011/** Initialise from the included word list. Won't work on Android. */ public MnemonicCode() throws IOException &#123; this(openDefaultWords(), BIP39_ENGLISH_SHA256); &#125; private static InputStream openDefaultWords() throws IOException &#123; InputStream stream = MnemonicCode.class.getResourceAsStream(BIP39_ENGLISH_RESOURCE_NAME); if (stream == null) throw new FileNotFoundException(BIP39_ENGLISH_RESOURCE_NAME); return stream; &#125; 可以从代码中看出来，在android平台此路径是绝对不可用的，所以我们要手动自己new这个对象，使用public MnemonicCode(InputStream wordstream, String wordListDigest) throws IOException, IllegalArgumentException这个构造函数 具体实现代码123456789101112131415public static void generateMnemonic(Context context) throws Exception &#123; MnemonicCode mnemonicCode = new MnemonicCode(context.getAssets().open(\"english.txt\"), null); SecureRandom secureRandom = SecureRandomUtils.secureRandom(); byte[] initialEntropy = new byte[16];//算法需要，必须是被4整除 secureRandom.nextBytes(initialEntropy); List&lt;String&gt; wd = mnemonicCode.toMnemonic(initialEntropy); if (wd == null || wd.size() != 12) throw new RuntimeException(\"generate word error\"); else &#123; words.clear(); words.addAll(wd); LogUtils.d(words.toString()); &#125;&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"}]},{"title":"区块链开发之确定性算法bip32，bip39，bip44","slug":"区块链开发之确定性算法bip32，bip39，bip44","date":"2018-07-30T09:34:40.000Z","updated":"2018-07-30T10:22:18.212Z","comments":true,"path":"2018/07/30/区块链开发之确定性算法bip32，bip39，bip44/","link":"","permalink":"https://52it.party/2018/07/30/区块链开发之确定性算法bip32，bip39，bip44/","excerpt":"","text":"引言随着比特币区块链的发展，人们已经不满足于，只有一个账号的情况，有些人会有好几个账户，但是这就出现一个问题，我有几个账号，就要保存几个私钥，这就特别麻烦和不友好，所以，就出现了bip32确定性算法，该算法可以让你只有同一个种子，就可以生成无数个私钥和地址，这就大大方便了用户的使用。但是这个种子，也不较长，用户使用起来也比较繁琐，这就出现了bip39，它是使用助记词的方式，生成种子的，这样用户只需要记住，12个单词（3,6,9,12，15,18,21，24支持这些单词数，目前使用较广泛的是12和24），这就有大大提高了用户使用的便利性。又随着区块链发展，市面上出现了很多币种，之前的确定性算法只是针对比特币的，也就是说只支持一种币种，用户想用同一个种子，管理不同币种，这就促使了bip39协议的出现，它是基于bip32协议的，它给bip32的路径，赋予了不同的意义，很好的解决了多币种，多地址的问题。 协议官方链接如果想详细的了解这些协议，请查看官方文档（解析的最清楚）big32：https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki bip39：https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki bip44：https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki 验证网站：https://iancoleman.io/bip39/ BIP44简介路径级别bip44给bip32定义了5各级别 m / purpose’ / coin_type’ / account’ / change / address_index m是固定的 Purpose也是固定的，值为44（或者 0x8000002C） Coin type这个代表的是币种，0代表比特币，1代表比特币测试链，60代表以太坊 完整的币种列表地址：https://github.com/satoshilabs/slips/blob/master/slip-0044.md Account代表这个币的账户索引，从0开始 Change常量0用于外部链，常量1用于内部链（也称为更改地址）。外部链用于在钱包外可见的地址（例如，用于接收付款）。内部链用于在钱包外部不可见的地址，用于返回交易变更。 (所以一般使用0) address_index这就是地址索引，从0开始，代表生成第几个地址，并且官方建议，每个account下的address_index不要超过20 示例 coin account change address path Bitcoin first external first m / 44’ / 0’ / 0’ / 0 / 0 Bitcoin first external second m / 44’ / 0’ / 0’ / 0 / 1 Bitcoin first internal second m / 44’ / 0’ / 0’ / 1 / 1 Bitcoin Testnet first external first m / 44’ / 1’ / 0’ / 0 / 0 Bitcoin Testnet second external first m / 44’ / 1’ / 1’ / 0 / 0","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"}]},{"title":"BTC,ETH测试币领取地址，以及对应区块浏览查询地址","slug":"BTC-ETH测试币领取地址，以及对应区块浏览查询地址","date":"2018-07-27T07:18:58.000Z","updated":"2018-09-07T03:51:00.832Z","comments":true,"path":"2018/07/27/BTC-ETH测试币领取地址，以及对应区块浏览查询地址/","link":"","permalink":"https://52it.party/2018/07/27/BTC-ETH测试币领取地址，以及对应区块浏览查询地址/","excerpt":"","text":"BTC测试币领取地址：https://testnet.manu.backend.hamburg/faucet BTC测试区块查询地址：https://www.blocktrail.com/BTC BTC测试区块查询地址：https://testnet.blockchain.info/ ETH（ropsten）测试币领取地址：http://faucet.ropsten.be:3001/ ETH（ropsten）测试区块查询地址：https://ropsten.etherscan.io/","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"BTC","slug":"BTC","permalink":"https://52it.party/tags/BTC/"},{"name":"ETH","slug":"ETH","permalink":"https://52it.party/tags/ETH/"},{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"}]},{"title":"区块链开发之区块链钱包","slug":"区块链开发之区块链钱包","date":"2018-07-25T07:13:12.000Z","updated":"2018-07-25T07:58:15.571Z","comments":true,"path":"2018/07/25/区块链开发之区块链钱包/","link":"","permalink":"https://52it.party/2018/07/25/区块链开发之区块链钱包/","excerpt":"","text":"引言“钱包”，大家都不陌生，因为我们每个人身上都会带一个钱包，里面存放了一些钱，一些证件，钥匙等等。而“区块链钱包”可能有些人就不是那么了解了。下边，我们就来介绍介绍区块链的钱包。 定义首先说明一点，这是我自己的定义。我觉着可以把区块链钱包当做是一个银行账户系统，它管理着你的在区块链上的资产，并且可以实现查看余额，转账，收账功，查看交易记录功能，而钱包应用就相当于银行的客户端，来实现钱包的具体功能。你的私钥就相当于银行账户的密码，你的地址就相当于银行的银行卡号。 钱包分类根据管理私钥的方式，大致分为，冷钱包，热钱包，软钱包，硬件钱包 冷钱包冷钱包就是，你把你的私钥，写在纸上，或者打印成二维码在纸上，或者记在你脑袋里，这类钱包一般就是为了安全保存私钥的，他不具备钱包的其它任何功能 热钱包热钱包就是，不是自己保管自己的私钥，而是钱包的开发者把私钥保存在服务器端，你所有的钱包操作都要经过服务器操作，这种钱包，等于是把自己的资产完全交给了别人，所以是最不安全的钱包，很少有人会用这种钱包 软钱包软钱包就是私钥保存在客户端本地，而不是保存在服务端，用户可以管理自己的私钥，相对于热钱包安全很多。软钱包又分为“全节点钱包”和“轻钱包”。 “全节点钱包”一般是钱包官方提供的钱包软件，它会把节点数据全部同步到本地，所以会花费很长时间同步数据，并且会占用很大的硬盘存储空间，所以对于个人用户来说，使用起来还是比较繁琐的，也就是说不适合个人用户使用 “轻钱包”是指不同步节点，转账使用离线签名，然后经过服务端节点广播出去，它的私钥也是保存的客户端本地的，用户可以自己管理，并且可以在手机这种移动端设备使用，所以现在最流行的就是这种“软钱包”，接下来的一系列文章也基本都是关于“轻钱包”开发的 硬件钱包硬件钱包，是指带有简单嵌入式系统的硬件设备，通过USB链接电脑，可以在硬件设备上进行创建私钥和地址的操作，并且离线签名也是硬件操作的，硬件管理着你的私钥。这是目前最安全的钱包，但是价格比较贵一些，市面上比较流行的硬件钱包大概为：TREZOR，Ledger，Keepkey，库神等，感兴趣的可以网上搜一下","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"}]},{"title":"区块链大数计算之java的BigDecimal类使用解析","slug":"区块链大数计算之java的BigDecimal类使用解析","date":"2018-07-24T05:32:22.000Z","updated":"2018-07-24T06:16:51.876Z","comments":true,"path":"2018/07/24/区块链大数计算之java的BigDecimal类使用解析/","link":"","permalink":"https://52it.party/2018/07/24/区块链大数计算之java的BigDecimal类使用解析/","excerpt":"","text":"之前讲解了BigInteger类的使用，这个类是做大整数运算的，想做大的浮点数运算就不行了，所以就需要其它的类来解决浮点运算的问题，这个类就是BigDecimal。 BigDecimal介绍不可变的、任意精度的有符号十进制数。BigDecimal 由任意精度的整数非标度值 和 32 位的整数标度 (scale) 组成。如果为零或正数，则标度是小数点后的位数。如果为负数，则将该数的非标度值乘以 10 的负 scale 次幂。因此，BigDecimal 表示的数值是 (unscaledValue × 10-scale)。 BigDecimal 类提供以下操作：算术、标度操作、舍入、比较、哈希算法和格式转换。toString() 方法提供 BigDecimal 的规范表示形式。 BigDecimal 类使用户能完全控制舍入行为。如果未指定舍入模式，并且无法表示准确结果，则抛出一个异常；否则，通过向该操作提供适当的 MathContext 对象，可以对已选择的精度和舍入模式执行计算。在任何情况下，可以为舍入控制提供八种舍入模式。使用此类（例如，ROUND_HALF_UP）中的整数字段来表示舍入模式已过时；应改为使用 RoundingMode enum（例如，RoundingMode.HALF_UP）的枚举值。 当为 MathContext 对象提供 0 的精度设置（例如，MathContext.UNLIMITED）时，算术运算是准确的，它们是不采用任何 MathContext 对象的算术方法。（这是第 5 版之前的版本支持的唯一行为。）为了计算准确结果，不使用附带 0 精度设置的 MathContext 对象的舍入模式设置，因此与该对象无关。在除法中，准确的商可能是一个无限长的十进制扩展；例如，1 除以 3 所得的商。如果商具有无穷的十进制扩展，但是指定了该操作返回准确结果，则抛出 ArithmeticException。否则，像其他操作那样，返回除法运算的准确结果。 当精度设置不为 0 时，BigDecimal 算法的规则完全符合 ANSI X3.274-1996 和 ANSI X3.274-1996/AM 1-2000（ 7.4 节）中定义的算法的可选操作模式。与上述标准不同，BigDecimal 包括多种舍入模式，它们对于版本 5 以前的 BigDecimal 版本中的除法是强制性的。这些 ANSI 标准和 BigDecimal 规范之间的任何冲突都按照有利于 BigDecimal 的方式进行解决。 由于同一数值可以有不同的表示形式（具有不同的标度），因此运算和舍入的规则必须同时指定数值结果和结果表示形式中所用的标度。 一般情况下，当准确结果（在除法中，可能有无限多位）比返回的数值具有更多位数时，舍入模式和精度设置确定操作如何返回具有有限位数的结果。 首先，MathContext 的 precision 设置指定要返回的总位数；这确定了结果的精度。位数计数从准确结果的最左边的非零数字开始。舍入模式确定丢弃的尾部位数如何影响返回的结果。 对于所有算术运算符，运算的执行方式是，首先计算准确的中间结果，然后，使用选择的舍入模式将其舍入为精度设置（如有必要）指定的位数。如果不返回准确结果，则将丢弃准确结果的某些数位。当舍入增加了返回结果的大小时，前导数字“9”的进位传播可能会创建新的数位。例如，将值 999.9 舍入为三位数字，则在数值上等于一千，表示为 100×101。在这种情况下，新的 “1” 是返回结果的前导数位。 除了逻辑的准确结果外，每种算术运算都有一个表示结果的首选标度。下表列出了每个运算的首选标度。 当为任何输入参数传递 null 对象引用时，此类的所有方法和构造方法都将抛出 NullPointerException。 字段摘要 类型 变量名 static BigDecimal ONE 值为 1，标度为 0。 static int ROUND_CEILING 接近正无穷大的舍入模式。如果 BigDecimal 为正，则舍入行为与 ROUND_UP 相同；如果为负，则舍入行为与 ROUND_DOWN 相同。注意，此舍入模式始终不会减少计算值。 static int ROUND_DOWN 接近零的舍入模式。在丢弃某部分之前始终不增加数字（即截短）。注意，此舍入模式始终不会增加计算值的大小。 static int RROUND_FLOOR 接近负无穷大的舍入模式。如果 BigDecimal 为正，则舍入行为与 ROUND_DOWN 相同；如果为负，则舍入行为与 ROUND_UP 相同。注意，此舍入模式始终不会增加计算值。 static int ROUND_HALF_DOWN 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。如果舍弃部分 &gt; 0.5，则舍入行为与 ROUND_UP 相同；否则舍入行为与 ROUND_DOWN 相同。 static int ROUND_HALF_EVEN 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同；如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。注意，在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。 static int ROUND_HALF_UP 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。如果舍弃部分 &gt;= 0.5，则舍入行为与 ROUND_UP 相同；否则舍入行为与 ROUND_DOWN 相同。注意，这是我们大多数人在小学时就学过的舍入模式。 static int ROUND_UNNECESSARY 断言请求的操作具有精确的结果，因此不需要舍入。如果对获得精确结果的操作指定此舍入模式，则抛出 ArithmeticException。 static int ROUND_UP 舍入远离零的舍入模式。在丢弃非零部分之前始终增加数字。注意，此舍入模式始终不会减少计算值的大小。 static BigDecimal TEN 值为 10，标度为 0。 static BigDecimal ZERO 值为 0，标度为 0。 常用构造方法 构造方法 解释 public BigDecimal(String val) 将 BigDecimal 的字符串表示形式转换为 BigDecimal。字符串表示形式由可选符号’+’ (‘\\u002B’) 或 ‘-‘ (‘\\u002D’) 组成，后跟零或多个十进制数字（“整数”）的序列，可以选择后跟一个小数，也可以选择后跟一个指数。该小数由小数点以及后跟的零或更多十进制数字组成。字符串必须至少包含整数或小数部分中的一个数字。由符号、整数和小数部分组成的数字称为有效位数。 public BigDecimal(String val, MathContext mc) 将 BigDecimal 的字符串表示形式转换为 BigDecimal，接受与 BigDecimal(String) 构造方法相同的字符串（按照上下文设置进行舍入）。 public BigDecimal(double val) 将 double 转换为 BigDecimal，后者是 double 的二进制浮点值准确的十进制表示形式。返回的 BigDecimal 的标度是使 (10scale × val) 为整数的最小值。 public BigDecimal(BigInteger val) 将 BigInteger 转换为 BigDecimal。BigDecimal 的标度是零 public BigDecimal(int val) 将 int 转换为 BigDecimal。BigDecimal 的标度为零。 public BigDecimal(long val) 将 long 转换为 BigDecimal。BigDecimal 的标度为零。 public BigDecimal(BigInteger unscaledVal,int scale) 将 BigInteger 非标度值和 int 标度转换为 BigDecimal。BigDecimal 的值为 (unscaledVal × 10-scale)。 常用方法 方法 解释 public static BigDecimal valueOf(long unscaledVal,int scale) 将 long 非标度值和 int 标度转换为 BigDecimal。提供的此“静态工厂方法”优先于 (long, int) 构造方法，因为前者允许重用经常使用的 BigDecimal 值。 public static BigDecimal valueOf(long val) 将 long 值转换为具有零标度的 BigDecimal。提供的此“静态工厂方法”优先于 (long) 构造方法，因为前者允许重用经常使用的 BigDecimal 值。 public static BigDecimal valueOf(double val) 使用 Double.toString(double) 方法提供的 double 规范的字符串表示形式将 double 转换为 BigDecimal。 注：这通常是将 double（或 float）转化为 BigDecimal 的首选方法，因为返回的值等于从构造 BigDecimal（使用 Double.toString(double) 得到的结果）得到的值。 public BigDecimal add(BigDecimal augend) 返回一个 BigDecimal，其值为 (this + augend)，其标度为 max(this.scale(), augend.scale())。 public BigDecimal subtract(BigDecimal subtrahend) 返回一个 BigDecimal，其值为 (this - subtrahend)，其标度为 max(this.scale(), subtrahend.scale())。 public BigDecimal multiply(BigDecimal multiplicand) 返回一个 BigDecimal，其值为 (this × multiplicand)，其标度为 (this.scale() + multiplicand.scale())。 public BigDecimal divide(BigDecimal divisor) 返回一个 BigDecimal，其值为 (this / divisor)，其首选标度为 (this.scale() - divisor.scale())；如果无法表示准确的商值（因为它有无穷的十进制扩展），则抛出 ArithmeticException。 public BigDecimal remainder(BigDecimal divisor) 返回其值为 (this % divisor) 的 BigDecimal。 余数由 this.subtract(this.divideToIntegralValue(divisor).multiply(divisor)) 给出。注意，这不是模操作（结果可以为负）。 public BigDecimal pow(int n) 返回其值为 (thisn) 的 BigDecimal，准确计算该幂，使其具有无限精度。 参数 n 必须在 0 到 999999999（包括）之间。ZERO.pow(0) 返回 ONE。 注意，未来版本可能会扩展此方法允许的指数范围。 public BigDecimal abs() 返回 BigDecimal，其值为此 BigDecimal 的绝对值，其标度为 this.scale()。 public BigDecimal plus() 返回 BigDecimal，其值为 (+this)，其标度为 this.scale()。 public BigDecimal setScale(int newScale, RoundingMode roundingMode) 返回 BigDecimal，其标度为指定值，其非标度值通过此 BigDecimal 的非标度值乘以或除以十的适当次幂来确定，以维护其总值。如果该操作减少标度，则非标度值必须被除（而不是乘），并且该值可以更改；在这种情况下，将指定的舍入模式应用到除法中。 参数：newScale - 要返回的 BigDecimal 值的标度。roundingMode - 要应用的舍入模式。 public int compareTo(BigDecimal val) 当此 BigDecimal 在数字上小于、等于或大于 val 时，返回 -1、0 或 1。 public String toPlainString() 返回不带指数字段的此 BigDecimal 的字符串表示形式。对于具有正标度的值，小数点右边的数字个数用于指示标度。对于具有零或负标度的值，生成得到的字符串，好像将该值转换为在数值上等于具有零标度的值一样，并且好像零标度值的所有尾部零都出现在该结果中。 如果非标度值小于零，则整个字符串以减号 ‘-‘ (‘\\u002D’) 为前缀。如果非标度值为零或正数，则没有任何符号字符作为前缀。 注意，如果将此方法的结果传递到 string constructor，则只需要恢复此 BigDecimal 的数值；新的 BigDecimal 的表示形式可以有不同的标度。尤其是，如果此 BigDecimal 具有负标度，则在由字符串构造方法进行处理时，此方法产生的字符串将具有零标度。 （此方法的作用类似于 1.4 和更早版本中的 toString 方法。） public String toString() 返回此 BigDecimal 的字符串表示形式，如果需要指数，则使用科学记数法。 public String toEngineeringString() 返回此 BigDecimal 的字符串表示形式，需要指数时，则使用工程计数法。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"java","slug":"java","permalink":"https://52it.party/tags/java/"},{"name":"大数计算","slug":"大数计算","permalink":"https://52it.party/tags/大数计算/"}]},{"title":"java的random类的一个坑（集合乱序）","slug":"java的random类的一个坑","date":"2018-07-20T08:30:56.000Z","updated":"2018-07-20T09:06:06.161Z","comments":true,"path":"2018/07/20/java的random类的一个坑/","link":"","permalink":"https://52it.party/2018/07/20/java的random类的一个坑/","excerpt":"","text":"引言在最近的开发中，要实现一个把一个集合的数给弄成乱序的，脑子里边的第一个想法就是使用随机数，先新建一个集合，写个死循环，然后获取随机位置下标，然后判断新集合是否包含这个数，不包含就把这个数加入新集合，包含，就继续下次循环，一直到新集合的长度达到和原始数组一样的长度为止，代码如下： 123456789101112131415161718public List&lt;String&gt; randomList(List&lt;String&gt; words) &#123; if (words == null) return null; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Random random = new Random(); while (true) &#123; int i = random.nextInt(words.size()); // LogUtils.d(\"random:\" + i); String s = words.get(i); if (list.size() == words.size()) return list; if (list.contains(s)) continue; else list.add(s); &#125; &#125; 这段大吗是没啥问题，刚开始也是，运行的很好，但是过了一段时间之后，发现有的手机会出问题：这个死循环不会结束 后来经过调试，发现，有时候随机数会出现某一个数，一直随机不出不来，后来查阅文档发现，Random的nextInt(int n)方法有可能会出现问题： 该算法稍微有些复杂。它拒绝那些会导致不均匀分布的值（由于 2^31 无法被 n 整除）。某个值被拒绝的概率取决于 n。最坏的情况是 n=2^30+1，拒绝的概率是 1/2，循环终止前的预计迭代次数是 2。 这是倒霉催的遇上被拒绝的值了，所以应该不能一直nextInt(int n)同一个范围的值。 解决方案使用JDK自带的方法，Collections的shuffle方法，他的实现方式是： public static void shuffle(List&lt;?&gt; list) 使用默认随机源对指&gt; 定列表进行置换。所有置换发生的可能性都是大致相等的。前面描述中使用了不确定的词“大致”，因为随机源只是大致上独立选择位&gt; 的无偏源。如果它是一个随机选择位的最佳源，那么算法将完全一致的选&gt; 择置换。 此实现向后遍历列表，从最后一个元素一直到第二个元素，将随机选择的&gt; 元素重复交换到“当前位置”。元素是从列表的一部分随机选择的，该部分&gt; 列表从第一个元素一直到当前位置（包括）。 此方法以线性时间运行。如果指定列表没有实现 RandomAccess 接口并&gt; 且是一个大型列表，则此实现在改组列表前将指定列表转储到数组中，并&gt; 将改组后的数组转储回列表中。这避免了二次行为，该行为是原地改组一&gt; 个“有序访问”列表引起的。 源码如下：1234567891011121314151617181920212223public static void shuffle(List&lt;?&gt; list, Random rnd) &#123; int size = list.size(); if (size &lt; SHUFFLE_THRESHOLD || list instanceof RandomAccess) &#123; for (int i=size; i&gt;1; i--) swap(list, i-1, rnd.nextInt(i)); &#125; else &#123; Object arr[] = list.toArray(); // Shuffle array for (int i=size; i&gt;1; i--) swap(arr, i-1, rnd.nextInt(i)); // Dump array back into list // instead of using a raw type here, it's possible to capture // the wildcard but it will require a call to a supplementary // private method ListIterator it = list.listIterator(); for (int i=0; i&lt;arr.length; i++) &#123; it.next(); it.set(arr[i]); &#125; &#125; &#125; 可以看出，它每次nextInt（）的随机源是不一样的，所以很好的解决了我碰到的那个问题 修改后的方法代码如下：12345678public List&lt;String&gt; randomList(List&lt;String&gt; words) &#123; if (words == null) return null; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.addAll(words); Collections.shuffle(list); return list; &#125;","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://52it.party/categories/问题解决/"}],"tags":[{"name":"java","slug":"java","permalink":"https://52it.party/tags/java/"},{"name":"问题解决","slug":"问题解决","permalink":"https://52it.party/tags/问题解决/"}]},{"title":"区块链开发之eth转账所需的gas，gasprice，gaslimit介绍","slug":"区块链开发之eth转账所需的gas，gasprice，gaslimit介绍","date":"2018-07-19T11:48:19.000Z","updated":"2018-07-19T12:01:59.569Z","comments":true,"path":"2018/07/19/区块链开发之eth转账所需的gas，gasprice，gaslimit介绍/","link":"","permalink":"https://52it.party/2018/07/19/区块链开发之eth转账所需的gas，gasprice，gaslimit介绍/","excerpt":"","text":"要了结以太坊的转账方式，首先要了解一下几个概念问题，那就是什么是gas，什么是gasprice，什么是gaslimit。 gasgas是以太坊交易中所花费的记账方式，在以太坊中，你要转账，部署智能合约，调用智能合约方法，都要消耗一定数量的gas gasprice之前说了gas，但是最终真正花的还是eth，所以就有一个转换率的问题，就像现实中的不同发币之间的汇率一样，gasprice就是起到一个汇率的作用，它代表的是一个gas值多少eth。 gaslimitgaslimit是做啥的呢，大家都知道以太坊的矿工记账，也是要收取手续费的，而手续费的最终是做少，是有记账所花的gas和gasprice决定的，所有的gas*gasprice就是最终的手续费，也就是从你账户扣除的eth，那gaslimit又是干啥的呢，以太坊规定，每笔交易的gas最少21000，矿工可以调整这个值，所以最终的花费的gas是不确定的，所以以太坊就设置了gaslimit，这个代表的是最多给旷工这么多gas，如果最终使用的gas少于这个gaslimit，剩余的还会返给你的，但是如果你的gaslimit不足以支付这次交易，那就是不会退回的，并且交易也就失败了，转账的额度也是回不来了，所以你转账设置的limit一定要大于21000。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"},{"name":"eth","slug":"eth","permalink":"https://52it.party/tags/eth/"}]},{"title":"区块链大数计算之java的BigInteger类使用解析","slug":"区块链大数计算之java的BigInteger类使用解析","date":"2018-07-19T11:02:37.000Z","updated":"2018-07-19T11:41:07.977Z","comments":true,"path":"2018/07/19/区块链大数计算之java的BigInteger类使用解析/","link":"","permalink":"https://52it.party/2018/07/19/区块链大数计算之java的BigInteger类使用解析/","excerpt":"","text":"引言区块链里面用的最多的就是计算，并且还是很大的数的计算。大家都知道java里面基本类型里面就long类型可以表示一个64位的大数字，其数值范围为： long的最大值：9223372036854775807 long的最小值：-9223372036854775808 这个数，看起来很大了，但是对于区块链来说完全是不够的，大家可以看一下我之前的一篇文章：区块链开发以太坊ETH单位转换关系 这里边的数值都很大，做运算时，绝对不可能使用基本类型来做运算的。还好jdk里面已经内置了相关的类来解决这些问题，那就是BigInteger（主要做整数运算）和BigDecimal（主要做浮点运算），今天我们就来介绍一下BigInteger的用法（后边会写和BigDecimal的用法）： 常用构造方法123BigInteger(String val) //将 BigInteger 的十进制字符串表示形式转换为 BigInteger。 BigInteger(String val, int radix) //将指定基数的 BigInteger 的字符串表示形式转换为 BigInteger。 radix只得是进制，比如2进制，就填写2,16进制，就填16 常用方法1.求绝对值1abs()//返回其值是此 BigInteger 的绝对值的 BigInteger。 2.加法1add(BigInteger val) //相当于做加法，返回其值为 (this + val) 的 BigInteger。 3.比较大小1compareTo(BigInteger val)//比较大小，大于返回1，等于返回0，小于返回-1 4.除法1divide(BigInteger val)//相当于做除法 返回其值为 (this / val) 的 BigInteger。 5.转成double1doubleValue()//将此 BigInteger 转换为 double。如果此 BigInteger 的数量太大，不能表示为 double，则将其适当地转换为 Double.NEGATIVE_INFINITY 或 Double.POSITIVE_INFINITY。注意，即使在返回值是有限的情况下，此转换也可以丢失关于 BigInteger 值的精度的信息。 6.转换为 float1floatValue() //将此 BigInteger 转换为 float。如果此 BigInteger 的数量太大，不能表示为 float，则将其适当地转换为 Float.NEGATIVE_INFINITY 或 Float.POSITIVE_INFINITY。注意，即使在返回值是有限的情况下，此转换也可以丢失关于 BigInteger 值的精度的信息。 7.转换为 int1intValue() //将此 BigInteger 转换为 int。如果此 BigInteger 太长而不适合用 int 表示，则仅返回 32 位的低位字节。注意，此转换会丢失关于该 BigInteger 值的总大小的信息，并返回带有相反符号的结果 7.转换为 long1longValue() //将此 BigInteger 转换为 long。如果此 BigInteger 太长而不适合用 long 表示，则仅返回 64 位的低位字节。注意，此转换会丢失关于该 BigInteger 值的总大小的信息，并返回带有相反符号的结果。 8.乘法1multiply(BigInteger val) //返回其值为 (this * val) 的 BigInteger。 9.减法1subtract(BigInteger val)//返回其值为 (this - val) 的 BigInteger。 10.转成十进制字符串表示形式字符串1toString() //返回此 BigInteger 的十进制字符串表示形式。 11.转成2,8,10,16进制字符串表示形式字符串1toString(int radix)//返回此 BigInteger 的给定基数的字符串表示形式。radix为进制数 Tip:其他方法可以查看帮助文档","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"java","slug":"java","permalink":"https://52it.party/tags/java/"},{"name":"大数计算","slug":"大数计算","permalink":"https://52it.party/tags/大数计算/"}]},{"title":"区块链开发以太坊ETH单位转换关系","slug":"区块链开发之以太坊ETH单位转换关系","date":"2018-07-19T06:31:48.000Z","updated":"2018-07-19T06:44:50.833Z","comments":true,"path":"2018/07/19/区块链开发之以太坊ETH单位转换关系/","link":"","permalink":"https://52it.party/2018/07/19/区块链开发之以太坊ETH单位转换关系/","excerpt":"","text":"以太坊中的计价单位要比比特币的多一些，并且数值上也要大很多，超过了64位的无符号long的最大值，他们计价单位一共有，wei，kwei，mwei，gwei，szabo，finney，ether，kether，mether，gether这10种计价单位，他们之间的转换关系如下： 1kwei = 10^3wei(10的 3次幂) 1mwei = 10^6wei(10的 6次幂) 1gwei = 10^9wei(10的 9次幂) 1szabo = 10^12wei(10的 12次幂) 1finney = 10^15wei(10的 15次幂) 1ether = 10^18wei(10的 18次幂) 1kether = 10^21wei(10的 21次幂) 1mether = 10^24wei(10的 24次幂) 1gether = 10^27wei(10的 27次幂)","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"eth","slug":"eth","permalink":"https://52it.party/tags/eth/"},{"name":"以太坊","slug":"以太坊","permalink":"https://52it.party/tags/以太坊/"}]},{"title":"区块链开发比特币btc单位转换关系","slug":"区块链开发之比特币btc单位转换关系","date":"2018-07-19T06:24:32.000Z","updated":"2018-07-19T06:31:17.302Z","comments":true,"path":"2018/07/19/区块链开发之比特币btc单位转换关系/","link":"","permalink":"https://52it.party/2018/07/19/区块链开发之比特币btc单位转换关系/","excerpt":"","text":"今天来说一下比特币BTC的单位之间的转换关系，比特币有5种计价单位，btc，cbtc，mbtc，ubtc/μbtc，satoshi,其中satoshi是最小的单位，也是一笔交易中真正使用到的计价单位、之间的转化关系如下： 1比特币（Bitcoins，BTC） 0.01比特分（Bitcent，cBTC） 0.001毫比特（Milli-Bitcoins，mBTC） 0.000001微比特（Micro-Bitcoins，μBTC或uBTC） 0.00000001聪（satoshi）（基本单位） 1 bitcoin (BTC) = 1000 millibitcoins (mBTC) = 1 million microbitcoins (uBTC) 也就是100 0000 = 100 million Satoshi 也就是1亿（10000 0000）","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"btc","slug":"btc","permalink":"https://52it.party/tags/btc/"},{"name":"比特币","slug":"比特币","permalink":"https://52it.party/tags/比特币/"},{"name":"bitcoin","slug":"bitcoin","permalink":"https://52it.party/tags/bitcoin/"}]},{"title":"小米刘海屏适配方案","slug":"小米刘海屏适配方案","date":"2018-07-16T06:19:35.000Z","updated":"2018-07-16T06:44:32.073Z","comments":true,"path":"2018/07/16/小米刘海屏适配方案/","link":"","permalink":"https://52it.party/2018/07/16/小米刘海屏适配方案/","excerpt":"","text":"背景1.目前已上市的小米 Notch 设备（俗称刘海屏手机）如下，其宽度、高度和形状均略有差异。 机型 model device 分辨率 Notch高度 Notch宽度 DPI 小米8 Xiaomi MI 8 dipper 1080*2248 89 560 440 小米8 SE Xiaomi MI 8 SE sirius 1080*2244 85 540 440 小米8 透明探索版 Xiaomi MI8 Explorer Edition ursa 1080*2248 89 560 440 红米6 Pro Xiaomi Redmi 6 Pro sakura 1080*2280 89 352 440 注：以上设备，由于MIUI调整了DPI值，因此DP值与像素值的转换关系是 1dp = 2.75 px 。 2..Android P 提供了 Notch / 刘海屏的标准适配接口 MIUI 也将在 Android P 上采用标准接口，因此，下文提及的接口仅用于 Android O 上。关于 Android P 的接口说明，详见我的之前的文章：谷歌官方流海适配方案。 系统级适配规则Notch 机型在界面上会带来两个问题： 顶部内容会被 Notch 遮挡 如何处理耳朵区的显示区域 为了保证绝大部分应用都能正常显示，同时尽可能利用屏幕的显示区域。MIUI System UI 制定了以下全局规则： status bar 略高于 Notch 高度，对于应用来说，相当于一个更高的 status bar。 当应用显示 status bar 时（如微信首页），允许应用使用耳朵区（背后的逻辑是：因为 status bar 区域本身不可交互，且会显示信号、电池等信息，因此我们假定应用不会在该区域放置重要的内容和可交互的控件）。 当应用不显示 status bar 时（如全屏游戏），不允许应用使用耳朵区，系统默认填黑。 横屏时，默认均不允许使用耳朵区，系统默认填黑。 不允许应用180度倒转显示。 开发者适配系统规则只能解决最基础的可用性问题，在系统规则下，开发者仍需要检查以下内容： 检查系统默认规则是否有可用性问题，考虑是否做针对性优化。 检查 status bar 的显示策略。重新考虑是否隐藏 status bar 尽量避免某些页面显示 status bar，某些页面又隐藏，否则会出现页面跳变的情况（应用的可用高度变了）。 检查横屏的情况，确定是否需要利用横屏的Notch，若使用，需兼顾 Notch 出现在左边/右边的情况。 检查是否写死了状态栏的高度值。Notch机器状态栏的值是变化的，建议改为读取系统的值（后有相关方法说明）。 检查开启「隐藏屏幕刘海」后，应用是否显示异常（详见后文）。 检查普通屏幕的显示，保证应用在普通屏幕和 Notch 屏幕下都能正常显示 。 系统接口说明1.如何判断设备为 Notch 机型1SystemProperties.getInt(\"ro.miui.notch\", 0) == 1;//系统增加了 property ro.miui.notch，值为1时则是 Notch 屏手机。 2.如何获取 Notch / 凹口 / 刘海 的高度和宽度（截至2018.6.26）MIUI 10 新增了获取刘海宽和高的方法，需升级至8.6.26开发版及以上版本。 以下是获取当前设备刘海高度的方法:1234int resourceId = context.getResources().getIdentifier(\"notch_height\", \"dimen\", \"android\");if (resourceId &gt; 0) &#123;result = context.getResources().getDimensionPixelSize(resourceId);&#125; 以下是获取当前设备刘海宽度的方法：1234int resourceId = context.getResources().getIdentifier(\"notch_width\", \"dimen\", \"android\");if (resourceId &gt; 0) &#123;result = context.getResources().getDimensionPixelSize(resourceId);&#125; 3.Application 级别的控制接口如果开发者认为应用的所有页面统一处理就行，可以使用该接口。在 Application 下增加一个 meta-data，用以声明该应用是否使用耳朵区。示例如下：123&lt;meta-data android:name=\"notch.config\" android:value=\"portrait|landscape\"/&gt; 其中，value 的取值可以是以下4种： “none” 横竖屏都不绘制耳朵区 “portrait” 竖屏绘制到耳朵区 “landscape” 横屏绘制到耳朵区 “portrait|landscape” 横竖屏都绘制到耳朵区 注：一旦开发者声明了meta-data，系统就会优先遵从开发者的声明。 4.Window 级别的控制接口如果开发者希望对特定 Window 作处理，可以使用该接口。 在 WindowManager.LayoutParams 增加 extraFlags 成员变量，用以声明该 window 是否使用耳朵区。 其中，extraFlags 有以下变量： 0x00000100 开启配置 0x00000200 竖屏配置 0x00000400 横屏配置 组合后表示 Window 的配置，如： 0x00000100 | 0x00000200 竖屏绘制到耳朵区 0x00000100 | 0x00000400 横屏绘制到耳朵区 0x00000100 | 0x00000200 | 0x00000400 横竖屏都绘制到耳朵区 控制 extraFlags 时注意只控制这几位，不要影响其他位。可以用 Window 的 addExtraFlags 和 clearExtraFlags 来修改, 这两个方法是 MIUI 增加的方法，需要反射调用。12345678int flag = 0x00000100 | 0x00000200 | 0x00000400;try &#123; Method method = Window.class.getMethod(\"addExtraFlags\", int.class); method.invoke(getWindow(), flag);&#125; catch (Exception e) &#123; Log.i(TAG, \"addExtraFlags not found.\");&#125; 5.状态栏高度获取方法由于 Notch 设备的状态栏高度与正常机器不一样，因此在需要使用状态栏高度时，不建议写死一个值，而应该改为读取系统的值。 以下是获取当前设备状态栏高度的方法：1234int resourceId = context.getResources().getIdentifier(\"status_bar_height\", \"dimen\", \"android\");if (resourceId &gt; 0) &#123;result = context.getResources().getDimensionPixelSize(resourceId);&#125; 「隐藏屏幕刘海」适配MIUI 针对 Notch 设备，有一个「隐藏屏幕刘海」的设置项（设置-全面屏-隐藏屏幕刘海），具体表现是：系统会强制盖黑状态栏（无视应用的Notch使用声明），视觉上达到隐藏刘海的效果。但会给某些应用带来适配问题（控件/内容遮挡或过于靠边等）。 因此开发者在适配时，还需要检查开启「隐藏屏幕刘海」后，应用的页面是否显示正常。针对有问题的页面，我们建议： 1.请通过以下方法获取系统状态栏高度，然后据此调整布局，而不是写死布局：1234int resourceId = context.getResources().getIdentifier(\"status_bar_height\", \"dimen\", \"android\");if (resourceId &gt; 0) &#123; result = context.getResources().getDimensionPixelSize(resourceId);&#125; 2.如有需要，可以通过查询以下 Global settings 来确定「隐藏屏幕刘海」是否开启了，然后再作针对性优化。1Settings.Global.getInt(mContext.getContentResolver(), \"force_black\", 0) == 1","categories":[{"name":"android刘海屏方案解决","slug":"android刘海屏方案解决","permalink":"https://52it.party/categories/android刘海屏方案解决/"}],"tags":[{"name":"android刘海屏方案解决","slug":"android刘海屏方案解决","permalink":"https://52it.party/tags/android刘海屏方案解决/"},{"name":"android解决方案","slug":"android解决方案","permalink":"https://52it.party/tags/android解决方案/"}]},{"title":"华为刘海屏适配","slug":"华为刘海屏适配","date":"2018-07-16T03:25:00.000Z","updated":"2018-07-16T03:46:26.973Z","comments":true,"path":"2018/07/16/华为刘海屏适配/","link":"","permalink":"https://52it.party/2018/07/16/华为刘海屏适配/","excerpt":"","text":"背景刘海屏指的是手机屏幕正上方由于追求极致边框而采用的一种手机解决方案。因形似刘海儿而得名。也有一些其他叫法：挖孔屏、凹口屏等，本文档统一按照刘海屏来命名。市场上已经有越来越多的手机都支持这种屏幕形式。 谷歌在安卓P版本中已经提供了统一的适配方案，可是在安卓O版本上如何适配呢？本文将详细介绍华为安卓O版本刘海屏适配方案。使用华为提供的刘海屏SDK进行适配，此方案也会继承到华为安卓P版本手机上。在华为P版本手机中将同时支持两种方案：华为O版本方案+谷歌P版本方案。另外因为安卓O版本的刘海屏手机已经在市场上大量上市，这些手机在市场上会存续2~3年。所以建议大家现在要同时适配华为O版本方案以及谷歌P版本方案。 华为刘海屏设计流程设计理念：尽量减少APP的开发工作量 处理逻辑： 从流程图可以看出，华为的手机刘海屏的处理流程中，只要我们应用是全屏显示或者横屏显示，只要我们未做适配，系统默认就是页面下移，所以我们只需要适配全屏显示和横屏显示的页面，其它页面，还是按照照常即可。 华为刘海屏API接口##1. 判断是否刘海屏 ##1234567891011121314151617181920212223242526272829303132public static boolean hasNotchInScreen(Context context) &#123; boolean ret = false; try &#123; ClassLoader cl = context.getClassLoader(); Class HwNotchSizeUtil = cl.loadClass(\"com.huawei.android.util.HwNotchSizeUtil\"); Method get = HwNotchSizeUtil.getMethod(\"hasNotchInScreen\"); ret = (boolean) get.invoke(HwNotchSizeUtil); &#125; catch (ClassNotFoundException e) &#123; Log.e(\"test\", \"hasNotchInScreen ClassNotFoundException\"); &#125; catch (NoSuchMethodException e) &#123; Log.e(\"test\", \"hasNotchInScreen NoSuchMethodException\");&#125; catch (Exception e) &#123; Log.e(\"test\", \"hasNotchInScreen Exception\"); &#125; finally &#123; return ret; &#125;&#125; 2. 获取刘海尺寸123456789101112131415161718192021222324252627282930313233343536/***int[0]值为刘海宽度 int[1]值为刘海高度*/public static int[] getNotchSize(Context context) &#123; int[] ret = new int[]&#123;0, 0&#125;;//int[0]值为刘海宽度 int[1]值为刘海高度 try &#123; ClassLoader cl = context.getClassLoader(); Class HwNotchSizeUtil = cl.loadClass(\"com.huawei.android.util.HwNotchSizeUtil\"); Method get = HwNotchSizeUtil.getMethod(\"getNotchSize\"); ret = (int[]) get.invoke(HwNotchSizeUtil); &#125; catch (ClassNotFoundException e) &#123; Log.e(\"test\", \"getNotchSize ClassNotFoundException\"); &#125; catch (NoSuchMethodException e) &#123; Log.e(\"test\", \"getNotchSize NoSuchMethodException\"); &#125; catch (Exception e) &#123; Log.e(\"test\", \"getNotchSize Exception\"); &#125; finally &#123; return ret; &#125;&#125; 应用页面设置使用刘海区显示1.方案一使用新增的Meta-data属性android.notch_support 在应用的AndroidManifest.xml中增加meta-data属性，此属性不仅可以针对Application生效，也可以对Activity配置生效。 具体方式如下所示：1&lt;meta-data android:name=\"android.notch_support\" android:value=\"true\"/&gt; 对Application生效，意味着该应用的所有页面，系统都不会做竖屏场景的特殊下移或者是横屏场景的右移特殊处理：12345678910111213141516171819202122232425262728293031&lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:testOnly=\"false\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;meta-data android:name=\"android.notch_support\" android:value=\"true\"/&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 对Activity生效，意味着可以针对单个页面进行刘海屏适配，设置了该属性的Activity系统将不会做特殊处理：1234567891011121314151617181920&lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:testOnly=\"false\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".LandscapeFullScreenActivity\" android:screenOrientation=\"sensor\"&gt; &lt;/activity&gt; &lt;activity android:name=\".FullScreenActivity\"&gt; &lt;meta-data android:name=\"android.notch_support\" android:value=\"true\"/&gt; &lt;/activity&gt; 2.方案二使用给window添加新增的FLAG_NOTCH_SUPPORT对Application生效，意味着该应用的所有页面，系统都不会做竖屏场景的特殊下移或者是横屏场景的右移特殊处理：123456789101112131415161718192021222324/*刘海屏全屏显示FLAG*/public static final int FLAG_NOTCH_SUPPORT=0x00010000;/** * 设置应用窗口在华为刘海屏手机使用刘海区 * @param window 应用页面window对象 */public static void setFullScreenWindowLayoutInDisplayCutout(Window window) &#123; if (window == null) &#123; return; &#125; WindowManager.LayoutParams layoutParams = window.getAttributes(); try &#123; Class layoutParamsExCls = Class.forName(\"com.huawei.android.view.LayoutParamsEx\"); Constructor con=layoutParamsExCls.getConstructor(LayoutParams.class); Object layoutParamsExObj=con.newInstance(layoutParams); Method method=layoutParamsExCls.getMethod(\"addHwFlags\", int.class); method.invoke(layoutParamsExObj, FLAG_NOTCH_SUPPORT); &#125; catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException |InstantiationException | InvocationTargetException e) &#123; Log.e(\"test\", \"hw add notch screen flag api error\"); &#125; catch (Exception e) &#123; Log.e(\"test\", \"other Exception\"); &#125;&#125; 可以通过clearHwFlags接口清除添加的华为刘海屏Flag，恢复应用不使用刘海区显示。123456789101112131415161718192021222324/*刘海屏全屏显示FLAG*/public static final int FLAG_NOTCH_SUPPORT=0x00010000;/** * 设置应用窗口在华为刘海屏手机使用刘海区 * @param window 应用页面window对象 */public static void setNotFullScreenWindowLayoutInDisplayCutout (Window window) &#123; if (window == null) &#123; return; &#125; WindowManager.LayoutParams layoutParams = window.getAttributes(); try &#123; Class layoutParamsExCls = Class.forName(\"com.huawei.android.view.LayoutParamsEx\"); Constructor con=layoutParamsExCls.getConstructor(LayoutParams.class); Object layoutParamsExObj=con.newInstance(layoutParams); Method method=layoutParamsExCls.getMethod(\"clearHwFlags\", int.class); method.invoke(layoutParamsExObj, FLAG_NOTCH_SUPPORT); &#125; catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException |InstantiationException | InvocationTargetException e) &#123; Log.e(\"test\", \"hw clear notch screen flag api error\"); &#125; catch (Exception e) &#123; Log.e(\"test\", \"other Exception\"); &#125;&#125; 华为刘海屏flag动态添加和删除代码：1234567891011121314btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if(isAdd) &#123;//add flag isAdd = false; NotchSizeUtil.setFullScreenWindowLayoutInDisplayCutout(getWindow()); getWindowManager().updateViewLayout(getWindow().getDecorView(),getWindow().getDecorView().getLayoutParams()); &#125; else&#123;//clear flag isAdd = true; NotchSizeUtil.setNotFullScreenWindowLayoutInDisplayCutout(getWindow()); getWindowManager().updateViewLayout(getWindow().getDecorView(),getWindow().getDecorView().getLayoutParams()); &#125; &#125;&#125;); 获取默认和隐藏刘海区开关值接口 隐藏开关打开之后，显示规格 读取开关状态:123public static final String DISPLAY_NOTCH_STATUS = \"display_notch_status\";int mIsNotchSwitchOpen = Settings.Secure.getInt(getContentResolver(),DISPLAY_NOTCH_STATUS, 0); // 0表示“默认”，1表示“隐藏显示区域”","categories":[{"name":"android刘海屏方案解决","slug":"android刘海屏方案解决","permalink":"https://52it.party/categories/android刘海屏方案解决/"}],"tags":[{"name":"android刘海屏方案解决","slug":"android刘海屏方案解决","permalink":"https://52it.party/tags/android刘海屏方案解决/"},{"name":"android解决方案","slug":"android解决方案","permalink":"https://52it.party/tags/android解决方案/"}]},{"title":"VIVO和OPPO刘海屏适配方案","slug":"VIVO和OPPO刘海屏适配方案","date":"2018-07-13T03:32:23.000Z","updated":"2018-07-13T04:06:03.748Z","comments":true,"path":"2018/07/13/VIVO和OPPO刘海屏适配方案/","link":"","permalink":"https://52it.party/2018/07/13/VIVO和OPPO刘海屏适配方案/","excerpt":"","text":"引言：今年蓝绿厂，可谓是大放异彩啊，首先vivo 发布了全面屏手机NEX，开创了伸缩式前置摄像头的显赫，oppo紧跟着发布了find x，可为惊艳全球啊。当然在这之前蓝绿厂也发布了很多的流海异形屏手机，并且官方也给出了一些是配置指导，蓝绿厂的适配指导可以说是，没有说是没有适配，为何这样说呢，因为它没做啥特殊处理，不像华为和小米一样做了一些特殊处理，所以只要你的app之前做了全面屏兼容处理，和沉浸式模式处理，就不必做其它特殊处理，但是这里，我还是要写一下他们官方提供的一些方法，有可能在做一些特殊处理的情况下会用得到。 1.判断是否刘海屏（凹凸屏）（1）oppo判断方式1context.getPackageManager().hasSystemFeature(“com.oppo.feature.screen.heteromorphism”);//返回 true为凹形屏 ，可识别OPPO的手机是否为凹形屏。 （2）vivo判断方式vivo不仅可以判断是否刘海屏，还可以判断时候有圆角，具体见以下代码： 12345678910111213141516171819public static final int NOTCH_IN_SCREEN_VOIO_MARK = 0x00000020;//是否有凹槽public static final int ROUNDED_IN_SCREEN_VOIO_MARK = 0x00000008;//是否有圆角public static boolean isFeatureSupportInVIVO(Context context，int mark)&#123; boolean ret = false; try &#123; ClassLoader cl = context.getClassLoader(); Class ftFeature = cl.loadClass(\"android.util.FtFeature\"); Method get = ftFeature.getMethod(\"isFeatureSupport\", int.class); ret = (boolean) get.invoke(ftFeature, mark); &#125; catch (ClassNotFoundException e) &#123; Log.e(\"test\", \"hasNotchInScreen ClassNotFoundException\"); &#125; catch (NoSuchMethodException e) &#123; Log.e(\"test\", \"hasNotchInScreen NoSuchMethodException\"); &#125; catch (Exception e) &#123; Log.e(\"test\", \"hasNotchInScreen Exception\"); &#125; finally &#123; return ret; &#125;&#125; 2.OPPO获取流海的详细信息 注:这个只有OPPO提供了，对应的方法凹形屏坐标获取方法：获取ro.oppo.screen.heteromorphism属性值可获取凹形区域的范围，例如 [ro.oppo.screen.heteromorphism]: [378,0:702,80]，含义如下 ： 378：表示竖屏下左上角横坐标 0 ：表示竖屏下左上角竖坐标 702：表示竖屏下右下角横坐标 80 ：表示竖屏下右下角竖坐标 如下图： 12345678910111213141516171819202122232425262728293031323334String mProperty = \"\"; mProperty = SystemProperties.get(\"ro.oppo.screen.heteromorphism\"); /***反射系统方法封装类调用方法：String mProperty = \"\"; mProperty = SystemProperties.get(\"ro.oppo.screen.heteromorphism\"); */public static class SystemProperties &#123; public static String get(String key) &#123; String value = \"\"; Class&lt;?&gt; cls = null; try &#123; cls = Class.forName(\"android.os.SystemProperties\"); Method hideMethod = cls.getMethod(\"get\", String.class); Object object = cls.newInstance(); value = (String) hideMethod.invoke(object, key); &#125; catch (ClassNotFoundException e) &#123; Log.e(\"error\", \"get error() \", e); &#125; catch (NoSuchMethodException e) &#123; Log.e(\"error\", \"get error() \", e); &#125; catch (InstantiationException e) &#123; Log.e(\"error\", \"get error() \", e); &#125; catch (IllegalAccessException e) &#123; Log.e(\"error\", \"get error() \", e); &#125; catch (IllegalArgumentException e) &#123; Log.e(\"error\", \"get error() \", e); &#125; catch (InvocationTargetException e) &#123; Log.e(\"error\", \"get error() \", e); &#125; return value; &#125; &#125;","categories":[{"name":"android刘海屏方案解决","slug":"android刘海屏方案解决","permalink":"https://52it.party/categories/android刘海屏方案解决/"}],"tags":[{"name":"android刘海屏方案解决","slug":"android刘海屏方案解决","permalink":"https://52it.party/tags/android刘海屏方案解决/"},{"name":"android解决方案","slug":"android解决方案","permalink":"https://52it.party/tags/android解决方案/"}]},{"title":"谷歌官方流海适配方案","slug":"谷歌官方流海适配方案","date":"2018-07-12T08:27:48.000Z","updated":"2018-07-12T09:14:32.059Z","comments":true,"path":"2018/07/12/谷歌官方流海适配方案/","link":"","permalink":"https://52it.party/2018/07/12/谷歌官方流海适配方案/","excerpt":"","text":"简介：随着去年iPhone X的发布，今年android厂商也紧随其后，发布了各种异形屏手机（国内习惯称为刘海屏），作为Android的东家，google也是大力支持这种方案，然后就决定在系统级予以支持，所以从Android P开始，就提供了相应的接口，适配刘海屏，并且华为和小米已经明确说明了，以后的新系统会兼容google官方的解决方案，所以接下来，我就介绍一下官方的解决方案。 适配方案：1.官方特性介绍谷歌称刘海屏为凹口屏以及屏幕缺口支持, 下面的内容摘自：https://developer.android.com/preview/features#cutout Android P 支持最新的全面屏以及为摄像头和扬声器预留空间的凹口屏幕。 通过全新的 DisplayCutout 类，可以确定非功能区域的位置和形状，这些区域不应显示内容。 要确定这些凹口屏幕区域是否存在及其位置，请使用 getDisplayCutout() 函数。 全新的窗口布局属性 layoutInDisplayCutoutMode 让您的应用可以为设备凹口屏幕周围的内容进行布局。 您可以将此属性设为下列值之一： （1）LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT （2）LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES （3）LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER 您可以按如下方法在任何运行 Android P 的设备或模拟器上模拟屏幕缺口： （1）启用开发者选项。 （2）在 Developer options 屏幕中，向下滚动至 Drawing 部分并选择 Simulate a display with a cutout。 （3）选择凹口屏幕的大小。 注：我们建议您通过使用运行 Android P 的设备或模拟器测试凹口屏幕周围的内容显示。 2.相关接口介绍（1）获取刘海尺寸相关接口： https://developer.android.com/reference/android/view/DisplayCutout 方法 接口说明 List getBoundingRects() 返回Rects的列表，每个Rects都是显示屏上非功能区域的边界矩形。设备的每个短边最多只有一个非功能区域，而长边上则没有。 int getSafeInsetBottom() 返回安全区域距离屏幕底部的距离，单位是px。 int getSafeInsetLeft () 返回安全区域距离屏幕左边的距离，单位是px。 int getSafeInsetRight () 返回安全区域距离屏幕右边的距离，单位是px。 int getSafeInsetTop () 返回安全区域距离屏幕顶部的距离，单位是px。 （2）设置是否延伸到刘海区显示接口：https://developer.android.com/reference/android/view/WindowManager.LayoutParams#layoutInDisplayCutoutMode 方法 接口说明 int layoutInDisplayCutoutMode 默认值：LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT其他可能取值：LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGESLAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES 常量 常量说明 int LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT 只有当DisplayCutout完全包含在系统状态栏中时，才允许窗口延伸到DisplayCutout区域显示。 int LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER 该窗口决不允许与DisplayCutout区域重叠。 int LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES 该窗口始终允许延伸到屏幕短边上的DisplayCutout区域。 3.代码实现（1）设置使用刘海区显示代码： 12345678//使内容出现在status bar后边，如果要使用全屏的话再加上View.SYSTEM_UI_FLAG_FULLSCREENgetWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN); //设置页面全屏显示WindowManager.LayoutParams lp = getWindow().getAttributes();lp.layoutInDisplayCutoutMode = windowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES; //设置页面延伸到刘海区显示getWindow().setAttributes(lp); （2）获取刘海屏安全显示区域和刘海尺寸信息：12345678910111213141516171819202122232425getWindow().getDecorView().setOnApplyWindowInsetsListener(new View.OnApplyWindowInsetsListener() &#123; @Override public WindowInsets onApplyWindowInsets(View view, WindowInsets windowInsets) &#123; DisplayCutout cutout = windowInsets.getDisplayCutout(); if (cutout == null) &#123; Log.e(TAG, \"cutout==null, is not notch screen\");//通过cutout是否为null判断是否刘海屏手机 &#125; else &#123; List&lt;Rect&gt; rects = cutout.getBoundingRects(); if (rects == null || rects.size() == 0) &#123; Log.e(TAG, \"rects==null || rects.size()==0, is not notch screen\"); &#125; else &#123; Log.e(TAG, \"rect size:\" + rects.size());//注意：刘海的数量可以是多个 for (Rect rect : rects) &#123; Log.e(TAG, \"cutout.getSafeInsetTop():\" + cutout.getSafeInsetTop() + \", cutout.getSafeInsetBottom():\" + cutout.getSafeInsetBottom() + \", cutout.getSafeInsetLeft():\" + cutout.getSafeInsetLeft() + \", cutout.getSafeInsetRight():\" + cutout.getSafeInsetRight() + \", cutout.rects:\" + rect ); &#125; &#125; &#125; return windowInsets; &#125;&#125;); UI适配1.判断是否为刘海屏见上边代码 2.调整布局如果是刘海屏，调整布局避开刘海区。 布局原则：保证重要的文字、图片、视频信息、可点击的控件和图标，应用弹窗等，建议显示在状态栏区域以下（安全区域）。如果内容不重要或者不会遮挡，布局可以延伸到状态栏区域（危险区域）。 建议按照如下布局原则修改： 3.获取状态栏高度 经过试验研究，小米和华为的获取的高度就是刘海的高度，并且在不同状态下这个值会有所变化 12345678public static int getStatusBarHeight(Context context) &#123; int result = 0; int resourceId = context.getResources().getIdentifier(\"status_bar_height\", \"dimen\", \"android\"); if (resourceId &gt; 0) &#123; result = context.getResources().getDimensionPixelSize(resourceId); &#125; return result;&#125;","categories":[{"name":"android刘海屏方案解决","slug":"android刘海屏方案解决","permalink":"https://52it.party/categories/android刘海屏方案解决/"}],"tags":[{"name":"android刘海屏方案解决","slug":"android刘海屏方案解决","permalink":"https://52it.party/tags/android刘海屏方案解决/"},{"name":"android解决方案","slug":"android解决方案","permalink":"https://52it.party/tags/android解决方案/"}]},{"title":"适配android全面屏","slug":"适配android全面屏","date":"2018-07-12T07:34:44.000Z","updated":"2018-07-12T08:07:29.278Z","comments":true,"path":"2018/07/12/适配android全面屏/","link":"","permalink":"https://52it.party/2018/07/12/适配android全面屏/","excerpt":"","text":"引言：随着android手机的发展，手机屏幕已经从4:3,16:9,16:10发展到现如今的所谓的全面屏，比例一般为18:9，18.9:9,19:9。 更大的屏幕高宽比：以三星S8为例，屏幕比例为18.5:9，从下图可以看到，在 1080P 的分辨率下，比标准的 16:9 屏幕，足足多了300像素。开发者需要作一些优化，以充分利用更大的显示空间。 这就会对一些app存在兼容性问题比如不能全屏显示啊等等，如下图所示： 今日头条在S8的效果 解决方式：1.声明 Maximum Aspect RatioAndroid 标准接口中，支持应用声明其支持的最大屏幕高宽比（maximum aspect ratio）。具体声明如下，其中的 ratio_float 被定义为是高除以宽，以 16:9 为例，ratio_float = 16/9 = 1.778 (18.5:9则为2.056)。 123&lt;application&gt; &lt;meta-data android:name=\"android.max_aspect\" android:value=\"ratio_float\" /&gt;&lt;/application&gt; 若开发者没有声明该属性，ratio_float 的默认值为1.86，小于2.056，因此这类应用在三星S8上，默认不会全屏显示，屏幕两边会留黑，如上图所示 因此建议开发者声明 Maximum Aspect Ratio 2 或更多。值得一提的是，如果应用的 android:resizeableActivity 已经设置为 true，就不必设置 Maximum Aspect Ratio 了。还有一点就是：如果您的应用面向 Android N，但未对android:resizeableActivity属性指定值，则该属性的值默认设为 true。 2.避免内容拉伸/变形从16:9变成18.5:9，图片往往被会拉伸变形，此问题常见于开屏素材。开发者应使用更灵活的布局，以适应不同的屏幕比例。 接下来我会出一系列的文章，说一下几种国产手机的刘海屏适配方案和google官方的适配方案","categories":[{"name":"android问题解决","slug":"android问题解决","permalink":"https://52it.party/categories/android问题解决/"}],"tags":[{"name":"android解决方案","slug":"android解决方案","permalink":"https://52it.party/tags/android解决方案/"},{"name":"android适配","slug":"android适配","permalink":"https://52it.party/tags/android适配/"}]},{"title":"一个兼容沉浸式模式的可以从上部和底部弹出的snackbar库","slug":"一个兼容沉浸式模式的可以从上部和底部弹出的snackbar库","date":"2018-07-11T11:07:51.000Z","updated":"2018-07-11T11:38:41.069Z","comments":true,"path":"2018/07/11/一个兼容沉浸式模式的可以从上部和底部弹出的snackbar库/","link":"","permalink":"https://52it.party/2018/07/11/一个兼容沉浸式模式的可以从上部和底部弹出的snackbar库/","excerpt":"","text":"简介：现在越来越多的app使用snackbar，google官方提供的一个提示工具，但是它只能从底部弹出来。但是在实际开发中，往往会和ios使用一套ui，ios流行从顶部弹出提示。为了同ios实现相同的效果，我特别封装了一个可以从上部和底部弹出的snackbar库，并且兼容沉浸模式，大体效果如下图： 效果动态图 github地址：https://github.com/wypeng2012/TopBottomSnackBar 注意：使用这个库必须api版本 &gt;= 14 使用方法：1. 从顶部弹出：要想从顶部弹出，要使用TBSnackbar.STYLE_SHOW_TOP模式，具体代码如下： 1234/* if you use STYLE_SHOW_TOP and your activity has toolbar oractionbar ,you should use \"findViewById(android.R.id.content)\",mustnot use \"getWindow().getDecorView()\"*/TBSnackbar.make(findViewById(android.R.id.content), \"This is a top snack!\", TBSnackbar.LENGTH_SHORT, TBSnackbar.STYLE_SHOW_TOP).show(); 2. 从底部弹出：要想从底部弹出，要使用TBSnackbar.STYLE_SHOW_BOTTOM模式，具体代码如下： 123// if you use STYLE_SHOW_BOTTOM ,you can use any view.But if you use//CoordinatorLayout,you must use CoordinatorLayout.TBSnackbar.make(findViewById(android.R.id.content), \"This is a bottom snack!\", TBSnackbar.LENGTH_SHORT,TBSnackbar.STYLE_SHOW_BOTTOM).show(); 3. 使用沉浸模式：使用沉浸模式，肯定是从顶部弹出，要使用TBSnackbar.STYLE_SHOW_TOP_FITSYSTEMWINDOW模式，具体代码如下： 123// if you use STYLE_SHOW_TOP_FITSYSTEMWINDOW ,you must use//getWindow().getDecorView() android api &gt;= 19 TBSnackbar.make(getWindow().getDecorView(),\"This is a fitsystemwindow snack!\", TBSnackbar.LENGTH_SHORT,TBSnackbar.STYLE_SHOW_TOP_FITSYSTEMWINDOW).show(); 4. 添加图标：123456//setIconLeft(@DrawableRes int drawableRes, float sizeDp) the size is dp,24dp is ok//if you want change the icon padding you can use setIconPadding(int padding)//setIconRight(@DrawableRes int drawableRes, float sizeDp) you can use TBSnackbar snackbar = TBSnackbar.make(findViewById(android.R.id.content), \"This is a left icon snack!\", TBSnackbar.LENGTH_SHORT, TBSnackbar.STYLE_SHOW_TOP);snackbar.setIconLeft(R.mipmap.ic_core,24);snackbar.show() 5. 添加action：123456789//you can use it like google's SnackBar final TBSnackbar snackbar = TBSnackbar.make(findViewById(android.R.id.content), \"This is a action snack!\", TBSnackbar.LENGTH_INDEFINITE, TBSnackbar.STYLE_SHOW_TOP);snackbar.setAction(\"Action\", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; snackbar.dismiss(); &#125; &#125;); snackbar.show(); 如何远程依赖：1. Maven123456&lt;dependency&gt; &lt;groupId&gt;com.github&lt;/groupId&gt; &lt;artifactId&gt;topbottomsnackbar&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; 2. Gradle1compile &apos;com.github:topbottomsnackbar:1.1.0&apos; 3. Ivy1234&lt;dependency org=&apos;com.github&apos; name=&apos;topbottomsnackbar&apos; rev=&apos;1.1.0&apos;&gt; &lt;artifact name=&apos;$AID&apos; ext=&apos;pom&apos;&gt; &lt;/artifact&gt;&lt;/dependency&gt;","categories":[{"name":"android开源库","slug":"android开源库","permalink":"https://52it.party/categories/android开源库/"}],"tags":[{"name":"java","slug":"java","permalink":"https://52it.party/tags/java/"},{"name":"android","slug":"android","permalink":"https://52it.party/tags/android/"}]},{"title":"给TextView上下左右添加图标","slug":"给TextView上下左右添加图标","date":"2018-07-10T10:03:07.000Z","updated":"2018-07-10T11:26:29.912Z","comments":true,"path":"2018/07/10/给TextView上下左右添加图标/","link":"","permalink":"https://52it.party/2018/07/10/给TextView上下左右添加图标/","excerpt":"","text":"简介：在Android开发中，经常会碰到一个图标加几个文字的界面，平常的解决方案可能是使用一个线性布局，然后放置图标和文字的位置，其实有一种更简单的方式实现这种布局，并且你可以在它的四个方向上都设置上图标。如下图： 四周都有图片的TextView 实现方式：1. xml文件实现 ，代码如下： 1234567891011&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:text=\"这是文字\" android:textColor=\"#fff\" android:drawableStart=\"@drawable/btc_logo\" android:drawableTop=\"@drawable/eth_logo\" android:drawableEnd=\"@drawable/btc_logo\" android:drawableBottom=\"@drawable/eth_logo\" android:drawablePadding=\"10dp\"/&gt; 代码解释： drawableStart：在左边画图标 drawableTop：在顶部画图标 drawableEnd：在右边画图标 drawableBottom：在底部画图标 drawablePadding：添加文字和图标之间的间距 大家可以根据具体需求，选择属性，实现自己想要的效果 2.代码实现：1）使用setCompoundDrawables（）方法 setCompoundDrawables(@Nullable Drawable left, @Nullable Drawable top, @Nullable Drawable right, @Nullable Drawable bottom) 四个参数分别为左，上，右，下，方位的图标，不想设置，就传null， 特别注意一点：在传Drawable值之前，必须先调用Drawable的setBounds方法，类似于这样：left.setBounds(0, 0, left.getIntrinsicWidth(), left.getIntrinsicHeight()); 2）使用setCompoundDrawablesWithIntrinsicBounds（）方法 setCompoundDrawablesWithIntrinsicBounds(@DrawableRes int left, @DrawableRes int top, @DrawableRes int right, @DrawableRes int bottom) 四个参数为图片的资源id 3）使用setCompoundDrawablesWithIntrinsicBounds（）方法 setCompoundDrawablesWithIntrinsicBounds(@Nullable Drawable left, @Nullable Drawable top, @Nullable Drawable right, @Nullable Drawable bottom) 四个参数为图片Drawable,不需要调用Drawable的setBounds方法 4）使用setCompoundDrawablesRelative系列方法代替以上对应的方法，它们的不同点也只是实现Drawable布局的方式不同而已","categories":[{"name":"android界面开发","slug":"android界面开发","permalink":"https://52it.party/categories/android界面开发/"}],"tags":[{"name":"android","slug":"android","permalink":"https://52it.party/tags/android/"},{"name":"android界面开发","slug":"android界面开发","permalink":"https://52it.party/tags/android界面开发/"}]},{"title":"给LinerLayout添加分隔线","slug":"给LinerLayout添加分隔线","date":"2018-07-09T11:43:03.000Z","updated":"2018-07-10T11:32:11.456Z","comments":true,"path":"2018/07/09/给LinerLayout添加分隔线/","link":"","permalink":"https://52it.party/2018/07/09/给LinerLayout添加分隔线/","excerpt":"简介：在android开发中，经常会碰到添加分隔线的界面设计，有些同学可能就是直接设置一个view，然后设置宽高和背景色，这也不失为一种方式，但是还有更简单方式，那就是利用LinerLayout自带的divider属性","text":"简介：在android开发中，经常会碰到添加分隔线的界面设计，有些同学可能就是直接设置一个view，然后设置宽高和背景色，这也不失为一种方式，但是还有更简单方式，那就是利用LinerLayout自带的divider属性 步骤：假设布局如下图： 设计图 在res/drawable/目录下创建一个shape的xml文件，里面代码如下： 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;solid android:color=\"#262936\"/&gt; &lt;size android:width=\"@dimen/dimen_1dp\" android:height=\"50dp\"/&gt;&lt;/shape&gt; 在你的layout布局中的LinearLayout，添加如下属性： 1234 android:divider=&quot;@drawable/divider_line&quot;android:dividerPadding=&quot;@dimen/dimen_20dp&quot;android:showDividers=&quot;middle&quot; dividerPadding的作用是设置分隔线的内边距 showDividers属性，是设置分隔线的显示位置，有四个flag，分别是：begining（开始位置），end（结束位置），middle（中间，最常见的），none（不显示，也是默认值）","categories":[{"name":"android界面开发","slug":"android界面开发","permalink":"https://52it.party/categories/android界面开发/"}],"tags":[{"name":"android","slug":"android","permalink":"https://52it.party/tags/android/"},{"name":"android界面开发","slug":"android界面开发","permalink":"https://52it.party/tags/android界面开发/"}]},{"title":"什么是区块链","slug":"什么是区块链","date":"2018-07-09T10:07:02.000Z","updated":"2018-07-09T11:25:32.891Z","comments":true,"path":"2018/07/09/什么是区块链/","link":"","permalink":"https://52it.party/2018/07/09/什么是区块链/","excerpt":"","text":"区块链历史： 2008年中本聪在互联网上一个讨论信息加密的邮件组中发表了一篇文章，勾画了比特币系统的基本框架，2009年他为该系统建立了一个开放源代码项目 (open source project)，正式宣告了比特币的诞生。（此大神已归隐）。 比特币可以说是世界上第一款区块链产品，这是一个革命性的产品。 2015年是国外区块链的元年， 世界许多重大组 织， 包括高盛、 花旗银行、 英国央行、 美国央行等机 构纷纷在区块链上面投资。 2016年1月， 英国首席科学家建议英国政府把区 块链技术列为英国国家战略， 这是区块链历史上一个 重大突破， 原因是基于华尔街以及金融机构对区块链 的评价。 2016年可以说是中国区块链元年， 因为在2016年 区块链在中国受到极大的重视。 首先是1月的时候， 人民银行宣布要使用数字货币。 然后在30日以后， 许 多中国的组织单位就开始投资区块链。 中国许多大学 也开始研究区块链技术， 大型金融机构都纷纷表态成 立区块链团队来研究区块链， 区块链的讨论班以及研 讨会如雨后春笋一般大量涌现 区块链第一代1.0：比特币是其代表，很多山寨币都是在其基础上修改而来的 区块链第二代2.0：毋庸置疑的，它就是以太坊，以太坊是图灵完备的第二代区块链技术，它对外提供了一个平台，在其平台，可以构建很多的应用，现在其平台已经存在很多的dapp应用，并且现在很多的ico项目，都是跑在以太坊平台上的 区块链第三代3.0：现在还没有一个定论，但是肯定很多人会说EOS，但是现在看来EOS还真不足以获得3.0的称号，EOS是基于石墨烯结构的区块链，还有基于DAG结构的区块链，这两种模式的，都号称自己是3.0，但是就我个人而言，我更看好IPFS，我觉着它可以担得起区块链3.0的称号（仅表达个人意思，不喜勿喷） 区块链的分类： 以参与方分类， 区块链可以分为： 公开链（Public Blockchain） 、 联盟链（ConsortiumBlockchain） 和私有链（Private Blockchain） 。 从链与链的关系来分， 可以分为主链和侧链。 而且， 不同区块链还可以形成网络， 网络中链与链的互联互通， 产生互联链（Interchain） 的概念。 比特币和以太坊都属于公有链范畴。EOS顶多属于联盟链，私有链暂未发现，“超级账本”（Hyperledger） 的开源项目也属于联盟链，感兴趣的可以搜索一下相关项目，做一下详细了解。 区块链的定义：区块链本质上是一个对等网络（peer-to-peer） 的分布式账本数据库。 比特币的底层就采用了区块链的技术架构。 区块链本身其实是一串链接的数据区块，其链接指针是采用密码学哈希算法对区块头进行处理所产生的区块头哈希值。 每一个数据块中记录了一组采用哈希算法组成的树状交易状态信息， 这样保证了每个区块内的交易数据不可篡改， 区块链里链接的区块也不可篡改。 区块链的特点： 去中心化 公正性和透明性 防伪、 防篡改 准匿名性 全网共识机制 交易可追溯 状态全网记录 安全性 合约自动执行 低成本及高效率","categories":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://52it.party/tags/区块链/"}]},{"title":"一个通用的顶部导航栏布局","slug":"一个通用的顶部导航栏布局","date":"2018-07-05T07:04:43.000Z","updated":"2018-07-05T08:00:04.012Z","comments":true,"path":"2018/07/05/一个通用的顶部导航栏布局/","link":"","permalink":"https://52it.party/2018/07/05/一个通用的顶部导航栏布局/","excerpt":"","text":"简介：在Android开发中，一个activity界面通常都会有一个顶部导航栏，有的是，左边一个返回按钮，中间一个标题，有的，右边还要几个文字，或者一个图标，更有甚者，左边有一个返回图标加几个文字，这种设计在android屡见不鲜，为了减少重复代码，我特别封装了一个控件commontopbar git地址：https://github.com/wypeng2012/commontopbar 欢迎star和提出问题 效果图如下： 使用方式： 在xml里面使用 123456&lt;party.loveit.commontopbar.CommonTopBar android:id=&quot;@+id/common&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:background=&quot;@color/top_bar_bg_color&quot;/&gt; 你的activity实现一个接口 12345public interface CommonTopBarClick &#123; void onClickLeft();//click left view on CommonTopBar void onClickRight();//click right view on CommonTopBar &#125; 设置监听 123mCommonTopBar = (CommonTopBar) findViewById(R.id.common); mCommonTopBar.setCommonTopBarClick(this);//of course you can not set it 显示或者隐藏view 123mCommonTopBar.isShowLeftView(true);mCommonTopBar.isShowRightView(true); 设置文字 123456789setLeftText(CharSequence charSequence) //set left view text setLeftText(int textRes) //set left view text setMidText(CharSequence charSequence) //set mid view text setMidText(int textRes) //set mid view text setRightText(CharSequence charSequence) //set right view text setRightText(int textRes) //set right view text 设置图片 123456setLeftImage(android.graphics.drawable.Drawable drawable) //set left imagesetLeftImage(int drawableRes) //set left image setRightImage(android.graphics.drawable.Drawable drawable) //set right imagesetRightImage(int drawableRes) //set right image 设置文字大小 123456setLeftTextSize(float size) //set left text size setMidTextSize(float size) //set mid text size setRightTextSize(float size) //set right text size 设置文字颜色 123456789setLeftTextColor(android.content.res.ColorStateList colorStateList) //set left text colorsetLeftTextColor(int color) //set left text color setMidTextColor(android.content.res.ColorStateList colorStateList) //set mid text color setMidTextColor(int color) //set mid text color setRightText(int textRes) //set right view textsetRightTextColor(android.content.res.ColorStateList colorStateList) //set right text color 添加margin 123addLeftMargin(float marginLeft) //set left view margin left,the param is dpaddRightMargin(float marginRight) //set right view margin right,the param is dp 设置中间title的字数长度 12setMidTextMaxLenth(int lenth) //set middle text max length 设置左边文字左边的图标 1234setLefTextViewDrawPadding(int size) ；//set DrawPaddingsetLeftTextViewDrawLeft(@DrawableRes int drawableRes)；//set left drawImgsetLeftTextViewDrawLeft(@NonNull Drawable drawableRes)；//set left drawImg 如何远程依赖： Maven 1234567&lt;dependency&gt; &lt;groupId&gt;party.loveit&lt;/groupId&gt; &lt;artifactId&gt;commontopbarlibrary&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; Gradle 1compile &apos;party.loveit:commontopbarlibrary:1.0.1&apos; Ivy 1234&lt;dependency org=&apos;party.loveit&apos; name=&apos;commontopbarlibrary&apos; rev=&apos;1.0.1&apos;&gt; &lt;artifact name=&apos;$AID&apos; ext=&apos;pom&apos;&gt;&lt;/artifact&gt;&lt;/dependency&gt;","categories":[{"name":"android开源库","slug":"android开源库","permalink":"https://52it.party/categories/android开源库/"}],"tags":[{"name":"java","slug":"java","permalink":"https://52it.party/tags/java/"},{"name":"android","slug":"android","permalink":"https://52it.party/tags/android/"}]}]}